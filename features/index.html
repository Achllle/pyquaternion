<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Kieran Wynn">
        <link rel="canonical" href="http://kieranwynn.github.io/pyquaternion/features/">
        <link rel="shortcut icon" href="../img/favicon.ico">

        <title>Quaternion Features - pyquaternion</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link href="../css/prettify-1.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="..">pyquaternion</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../quaternion_basics">Quaternion Basics</a>
                </li>
            
            
            
                <li >
                    <a href="../initialisation">Object Initialisation</a>
                </li>
            
            
            
                <li class="active">
                    <a href=".">Quaternion Features</a>
                </li>
            
            
            
                <li >
                    <a href="../operations">Quaternion Operations</a>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                <li >
                    <a rel="next" href="../initialisation">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../operations">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/KieranWynn/pyquaternion">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#quaternion-features">Quaternion Features</a></li>
        
            <li><a href="#norm">Norm</a></li>
        
            <li><a href="#inversion">Inversion</a></li>
        
            <li><a href="#conjugation">Conjugation</a></li>
        
            <li><a href="#normalisation">Normalisation</a></li>
        
            <li><a href="#rotation">Rotation</a></li>
        
            <li><a href="#interpolation">Interpolation</a></li>
        
            <li><a href="#conversion-to-matrix-form">Conversion to matrix form</a></li>
        
            <li><a href="#accessing-rotation-axis">Accessing rotation axis</a></li>
        
            <li><a href="#accessing-rotation-angle">Accessing rotation angle</a></li>
        
            <li><a href="#accessing-real-components">Accessing real components</a></li>
        
            <li><a href="#accessing-imaginary-components">Accessing imaginary components</a></li>
        
            <li><a href="#accessing-individual-elements">Accessing individual elements</a></li>
        
            <li><a href="#modifying-individual-elements">Modifying individual elements</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="quaternion-features">Quaternion Features</h1>
<p>This page defines features available for pyquaternion's Quaternion objects</p>
<p>The code examples below assume the existence of a Quaternion object. You can recreate this by running the following in your Python interpreter of choice:</p>
<pre><code>my_quaternion = Quaternion.random()
</code></pre>
<h2 id="norm">Norm</h2>
<blockquote>
<p><strong><code>norm()</code> or <code>magnitude()</code></strong></p>
</blockquote>
<p>L2 norm of the quaternion 4-vector </p>
<p>This should be 1.0 for a unit quaternion (versor)</p>
<p><strong>Returns:</strong> a scalar real number representing the square root of the sum of the squares of the elements of the quaternion.</p>
<pre><code>my_quaternion.norm()
my_quaternion.magnitude()
</code></pre>
<hr />
<blockquote>
<p><strong><code>is_unit(tolerance=1e-14)</code></strong></p>
</blockquote>
<p><strong>Returns:</strong> <code>True</code> if the Quaternion object is of unit length to within the specified tolerance value. <code>False</code> otherwise.</p>
<p><strong>Params:</strong> </p>
<ul>
<li><code>tolerance</code> - maximum absolute value by which the norm can differ from 1.0 for the object to be considered a unit quaternion. Defaults to <code>1e-14</code>.</li>
</ul>
<h2 id="inversion">Inversion</h2>
<blockquote>
<p><strong><code>inverse()</code></strong></p>
</blockquote>
<p>Inverse of the quaternion object</p>
<p>For a unit quaternion, this is the inverse rotation, i.e. when combined with the original rotation, will result in the null rotation.</p>
<p><strong>Returns:</strong> a new Quaternion object representing the inverse of this object</p>
<pre><code>inv_quaternion = my_quaternion.inverse()
</code></pre>
<h2 id="conjugation">Conjugation</h2>
<blockquote>
<p><strong><code>conjugate()</code></strong></p>
</blockquote>
<p>Quaternion conjugate</p>
<p>For a unit quaternion, this is the same as the inverse.</p>
<p><strong>Returns:</strong> a new Quaternion object clone with its vector part negated</p>
<pre><code>conj_quaternion = my_quaternion.conjugate()
</code></pre>
<h2 id="normalisation">Normalisation</h2>
<blockquote>
<p><strong><code>normalised()</code> or <code>unit()</code></strong></p>
</blockquote>
<p>Get a unit quaternion (versor) copy of this Quaternion object.</p>
<p>A unit quaternion has a <code>norm()</code> of 1.0</p>
<p><strong>Returns:</strong> a new Quaternion object clone that is guaranteed to be a unit quaternion</p>
<pre><code>unit_quaternion = my_quaternion.normalise()
unit_quaternion = my_quaternion.unit()
</code></pre>
<h2 id="rotation">Rotation</h2>
<blockquote>
<p><strong><code>rotate(vector)</code></strong></p>
</blockquote>
<p>Rotate a 3D vector by the rotation stored in the Quaternion object</p>
<p><strong>Params:</strong></p>
<ul>
<li><code>vector</code> - a 3-vector specified as any ordered sequence of 3 real numbers corresponding to x, y, and z values. Some types that are recognised are: numpy arrays, lists and tuples. A 3-vector can also be represented by a Quaternion object who's scalar part is 0 and vector part is the required 3-vector. Thus it is possible to call <code>Quaternion.rotate(q)</code> with another quaternion object as an input.</li>
</ul>
<p><strong>Returns:</strong> the rotated vector returned as the same type it was specified at input.</p>
<pre><code>rotated_tuple       = my_quaternion.rotate((1, 0, 0)) # Returns a tuple
rotated_list        = my_quaternion.rotate([1.0, 0.0, 0.0]) # Returns a list
rotated_array       = my_quaternion.rotate(numpy.array([1.0, 0.0, 0.0])) # Returns a Numpy 3-array
rotated_quaternion  = my_quaternion.rotate(Quaternion(vector=[1, 0, 0])) # Returns a Quaternion object
</code></pre>
<blockquote>
<p>Raises <code>TypeError</code> if any of the vector elements cannot be converted to a real number.</p>
<p>Raises <code>ValueError</code> if <code>vector</code> cannot be interpreted as a 3-vector or a Quaternion object.</p>
</blockquote>
<h2 id="interpolation">Interpolation</h2>
<blockquote>
<p><strong><code>Quaternion.slerp(q0, q1, amount=0.5)</code></strong> - <em>class method</em></p>
</blockquote>
<p>Find a valid quaternion rotation at a specified distance along the minor arc of a great circle passing through any two existing quaternion endpoints lying on the unit radius hypersphere. <a href="http://en.wikipedia.org/wiki/Slerp#Quaternion_Slerp">Source</a></p>
<p>This is a class method and is called as a method of the class itself rather than on a particular instance.</p>
<p><strong>Params:</strong></p>
<ul>
<li><code>q0</code> - first endpoint rotation as a Quaternion object</li>
<li><code>q1</code> - second endpoint rotation as a Quaternion object</li>
<li><code>amount</code> - interpolation parameter between 0 and 1. This describes the linear placement position of the result along the arc between endpoints; 0 being at <code>q0</code> and 1 being at <code>q1</code>. Defaults to the midpoint (0.5).</li>
</ul>
<p><strong>Returns:</strong>
a new Quaternion object representing the interpolated rotation. This is guaranteed to be a unit quaternion.</p>
<blockquote>
<p><strong>Note:</strong> This feature only makes sense when interpolating between unit quaternions (those lying on the unit radius hypersphere). Calling this method will implicitly normalise the endpoints to unit quaternions if they are not already unit length.</p>
</blockquote>
<pre><code>q0 = Quaternion(axis=[1, 1, 1], angle=0.0)
q1 = Quaternion(axis=[1, 1, 1], angle=3.141592)
q  = Quaternion.slerp(q0, q1, 2.0/3.0) # Rotate 120 degrees (2 * pi / 3)
</code></pre>
<hr />
<blockquote>
<p><strong><code>Quaternion.intermediates(q_start, q_end, n, include_endpoints=False)</code></strong> - <em>class method</em></p>
</blockquote>
<p>Generator method to get an iterable sequence of <code>n</code> evenly spaced quaternion rotations between any two existing quaternion endpoints lying on the unit radius hypersphere. This is a convenience function that is based on <code>Quaternion.slerp()</code> as defined above.</p>
<p>This is a class method and is called as a method of the class itself rather than on a particular instance.</p>
<p><strong>Params:</strong></p>
<ul>
<li><code>q_start</code> - initial endpoint rotation as a Quaternion object</li>
<li><code>q_end</code> - final endpoint rotation as a Quaternion object</li>
<li><code>n</code> - number of intermediate quaternion objects to include within the interval</li>
<li><code>include_endpoints</code> - If set to <code>True</code>, the sequence of intermediates will be 'bookended' by <code>q_start</code> and <code>q_end</code>, resulting in a sequence length of <code>n + 2</code>. If set to <code>False</code>, endpoints are not included. Defaults to <code>False</code>.</li>
</ul>
<p><strong>Returns:</strong> 
a generator object iterating over a sequence of intermediate quaternion objects.</p>
<blockquote>
<p><strong>Note:</strong> This feature only makes sense when interpolating between unit quaternions (those lying on the unit radius hypersphere). Calling this method will implicitly normalise the endpoints to unit quaternions if they are not already unit length.</p>
</blockquote>
<pre><code>q0 = Quaternion(axis=[1, 1, 1], angle=0.0)
q1 = Quaternion(axis=[1, 1, 1], angle=2 * 3.141592 / 3)
for q in Quaternion.intermediates(q0, q1, 8, include_endpoints=True):
    v = q.rotate([1, 0, 0])
    print(v)
</code></pre>
<h2 id="conversion-to-matrix-form">Conversion to matrix form</h2>
<blockquote>
<p><strong><code>rotation_matrix()</code> &amp; <code>transformation_matrix()</code></strong></p>
</blockquote>
<p>Get the 3x3 rotation or 4x4 homogeneous transformation matrix equivalent of the quaternion rotation.</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Quaternion.rotation_matrix()</code> : a 3x3 orthogonal rotation matrix as a 3x3 Numpy array</li>
<li><code>Quaternion.transformation_matrix()</code> : a 4x4 homogeneous transformation matrix as a 4x4 Numpy array</li>
</ul>
<blockquote>
<p><strong>Note 1:</strong> This feature only makes sense when referring to a unit quaternion. Calling this method will implicitly normalise the Quaternion object to a unit quaternion if it is not already one.</p>
<p><strong>Note 2:</strong> Both matrices and quaternions avoid the singularities and discontinuities involved with rotation in 3 dimensions by adding extra dimensions. This has the effect that different values could represent the same rotation, for example quaternion q and -q represent the same rotation. It is therefore possible that, when converting a rotation sequence, the output may jump between these equivalent forms. This could cause problems where subsequent operations such as differentiation are done on this data. Programmers should be aware of this issue.</p>
</blockquote>
<pre><code>R = my_quaternion.rotation_matrix()         # 3x3 rotation matrix
T = my_quaternion.transformation_matrix()   # 4x4 transformation matrix
</code></pre>
<h2 id="accessing-rotation-axis">Accessing rotation axis</h2>
<blockquote>
<p><strong><code>axis()</code></strong></p>
</blockquote>
<p>Get the axis or vector about which the quaternion rotation occurs</p>
<p><strong>Returns:</strong> a Numpy unit 3-vector describing the Quaternion object's axis of rotation.</p>
<blockquote>
<p><strong>Note:</strong> This feature only makes sense when referring to a unit quaternion. Calling this method will implicitly normalise the Quaternion object to a unit quaternion if it is not already one.</p>
</blockquote>
<pre><code>u = my_quaternion.axis() # Unit vector about which rotation occurs
</code></pre>
<h2 id="accessing-rotation-angle">Accessing rotation angle</h2>
<blockquote>
<p><strong><code>angle()</code></strong></p>
</blockquote>
<p>Get the angle (in radians) describing the magnitude of the quaternion rotation about its rotation axis. This is guaranteed to be within the range (-pi:pi) with the direction of rotation indicated by the sign.</p>
<p><strong>Returns:</strong> a real number in the range (-pi:pi) describing the angle of rotation in radians about a Quaternion object's axis of rotation. </p>
<blockquote>
<p><strong>Note:</strong> This feature only makes sense when referring to a unit quaternion. Calling this method will implicitly normalise the Quaternion object to a unit quaternion if it is not already one.</p>
</blockquote>
<pre><code>theta = my_quaternion.angle() # Magnitude of rotation about the prescribed axis
</code></pre>
<h2 id="accessing-real-components">Accessing real components</h2>
<blockquote>
<p><strong><code>scalar()</code> or <code>real()</code></strong></p>
</blockquote>
<p>Get the real or scalar component of the Quaternion object</p>
<blockquote>
<p>A quaternion can be described in terms of a scalar and vector part, q = [r, <strong>v</strong>] where:</p>
<p>r is the scalar coefficient of the real part of the quaternion i.e. <strong>a</strong> in [a + b<em>i</em> + c<em>j</em> + d<em>k</em>]</p>
<p><strong>v</strong> is the 3-vector of coefficients to the imaginary parts of the quaternion i.e. <strong>[b, c, d]</strong> in [a + b<em>i</em> + c<em>j</em> + d<em>k</em>]</p>
</blockquote>
<p>This method returns r</p>
<p><strong>Returns</strong> the scalar, real valued element of the Quaternion object</p>
<pre><code>r = my_quaternion.scalar()
r = my_quaternion.real()
</code></pre>
<h2 id="accessing-imaginary-components">Accessing imaginary components</h2>
<blockquote>
<p><strong><code>vector()</code> or <code>imaginary()</code></strong></p>
</blockquote>
<p>Get the imaginary or vector component of the Quaternion object. This can be used, for example, to extract the stored vector when a pure-imaginary quaternion object is used to describe a vector within the three-dimensional vector space.</p>
<blockquote>
<p>A quaternion can be described in terms of a scalar and vector part, q = [r, <strong>v</strong>] where:</p>
<p>r is the scalar coefficient of the real part of the quaternion i.e. <strong>a</strong> in [a + b<em>i</em> + c<em>j</em> + d<em>k</em>]</p>
<p><strong>v</strong> is the 3-vector of coefficients to the imaginary parts of the quaternion i.e. <strong>[b, c, d]</strong> in [a + b<em>i</em> + c<em>j</em> + d<em>k</em>]</p>
</blockquote>
<p>This method returns <strong>v</strong></p>
<p><strong>Returns</strong> Numpy 3-array of the 3 imaginary elements of the Quaternion object</p>
<pre><code>v = my_quaternion.vector()
v = my_quaternion.imaginary()
</code></pre>
<h2 id="accessing-individual-elements">Accessing individual elements</h2>
<blockquote>
<p><strong><code>elements()</code></strong></p>
</blockquote>
<p>Return all four elements of the quaternion object. Result is not guaranteed to be a unit 4-vector.</p>
<p><strong>Returns:</strong> a numpy 4-array of real numbered coefficients.</p>
<pre><code>a = my_quaternion.elements()
print("{} + {}i + {}j + {}k".format(a[0], a[1], a[2], a[3]))
</code></pre>
<hr />
<blockquote>
<p><strong><code>__getitem__(index)</code></strong></p>
</blockquote>
<p><strong>Returns:</strong> the real numbered element at the specified index in the quaternion 4-array</p>
<p><strong>Params:</strong></p>
<ul>
<li><code>index</code> - integer in the range [-4:3] inclusive</li>
</ul>
<blockquote>
<p>Raises <code>IndexError</code> if the index provided is invalid</p>
<p>Raises <code>TypeError</code> or <code>ValueError</code> if the index cannot be interpreted as an integer</p>
</blockquote>
<pre><code>print("{} + {}i + {}j + {}k".format(my_quaternion[0], my_quaternion[1], my_quaternion[2], my_quaternion[3]))
print("{} + {}i + {}j + {}k".format(my_quaternion[-4], my_quaternion[-3], my_quaternion[-2], my_quaternion[-1]))
</code></pre>
<h2 id="modifying-individual-elements">Modifying individual elements</h2>
<blockquote>
<p><strong><code>__setitem__(index, value)</code></strong></p>
</blockquote>
<p>Set the element at the specified index in the quaternion 4-array to the specified value.</p>
<p><strong>Params:</strong></p>
<ul>
<li><code>index</code> - integer in the range [-4:3] inclusive</li>
<li><code>value</code> - real value to be inserted into the quaternion array at <code>index</code></li>
</ul>
<blockquote>
<p>Raises <code>IndexError</code> if the index provided is invalid</p>
<p>Raises <code>TypeError</code> or <code>ValueError</code> if the value cannot be interpreted as a real number</p>
</blockquote>
<pre><code>&gt;&gt;&gt; str(my_quaternion)
'-0.653 -0.127i -0.220j +0.714k'
&gt;&gt;&gt; my_quaternion[2] = 9
&gt;&gt;&gt; str(my_quaternion)
'-0.653 -0.127i +9.000j +0.714k'
&gt;&gt;&gt;
</code></pre>
</div>
        </div>

        

        <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/prettify-1.0.min.js"></script>
        <script src="../js/base.js"></script>
    </body>
</html>