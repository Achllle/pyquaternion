{
    "docs": [
        {
            "location": "/",
            "text": "Welcome\n\n\nWelcome! pyquaternion is a full-featured Python module for representing and using quaternions.\n\n\nThe following should get you up and running with pyquaternion in no time.\n\n\n\n\nGetting started\n\n\nThe following aims to familiarize you with the basic functionality of quaternions in pyquaternion. It provides an entry point and a quick orientation (no pun intended) for those who want get stuck straight in. More comprehensive feature summaries can be found in the \nfeatures\n and \noperations\n documentation.\n\n\nIf you want to learn more about quaternions and how they apply to certain problems, you can read about quaternions \nhere\n, and their application to rotations \nhere\n.\n\n\nInstallation\n\n\nTo start, you will need to install \npyquaternion\n into your environment.\n\n\n\n\n[Optional] If you are using virtual environments, switch to or create your environment of choice now:\n\n\n$ workon <my_environment>\n\n\n\n\nNow use pip to install \npyquaternion\n and its dependencies\n\n\n$ pip install pyquaternion\n\n\n\n\n\nNote: pyquaternion requires \nNumpy\n for the representation of arrays and matrices.\nChances are if you're needing quaternions, you've been dealing with numerical computation and you're already familiar with numpy.\nIf not, don't worry, it will be installed into your environment automatically.\n\n\n\n\nGreat, you now have pyquaternion installed and you're ready to roll. Or pitch. Or yaw. No judging here :)\n\n\nBasic Usage\n\n\nIn your code, simply import the \nQuaternion\n object from the \npyquaternion\n module:\n\n\n>>> from pyquaternion import Quaternion\n\n\n\nNext, create a Quaternion object to describe your desired rotation:\n\n\n>>> my_quaternion = Quaternion(axis=[1, 0, 0], angle=3.14159265)\n\n\n\n\n\nNote: There are many ways to create a Quaternion object. See the \ninitialisation\n section for a complete guide.\n\n\n\n\nNow you can do a bunch of useful things with your new quaternion object. Let's try rotating a vector:\n\n\n>>> import numpy\n>>> numpy.set_printoptions(suppress=True) # Suppress insignificant values for clarity\n>>> v = numpy.array([0., 0., 1.]) # Unit vector in the +z direction\n>>> v_prime = my_quaternion.rotate(v)\n>>> v_prime\n    array([ 0., 0., -1.])\n>>>\n\n\n\nA cool feature of quaternions is that they can be intuitively chained together to form a composite rotation from a sequence of discrete rotations:\n\n\n>>> q1 = Quaternion(axis=[1, 0, 0], angle=3.14159265) # Rotate 180 about X\n>>> q2 = Quaternion(axis=[0, 1, 0], angle=3.14159265 / 2) # Rotate 90 about Y\n>>> q3 = q1 * q2 # Composite rotation of q1 then q2 expressed as standard multiplication\n>>> v_prime = q3.rotate(v)\n>>> v_prime\n    array([ 1., 0., 0.])\n>>>\n\n\n\nQuaternions are used extensively in animation to describe smooth transitions between known orientations. This is known as interpolation. This is an example of an area where quaternions are preferred to rotation matrices as smooth interpolation is not possible with the latter. Here's quaternion interpolation in action:\n\n\n>>> import numpy\n>>> numpy.set_printoptions(suppress=True) # Suppress insignificant values for clarity\n>>> v = numpy.array([0., 0., 1.]) # Unit vector in the +z direction\n>>> q0 = Quaternion(axis=[1, 1, 1], angle=0.0) # Rotate 0 about x=y=z\n>>> q1 = Quaternion(axis=[1, 1, 1], angle=2 * 3.14159265 / 3) # Rotate 120 about x=y=z\n>>> for q in Quaternion.intermediates(q0, q1, 8, include_endpoints=True):\n...     v_prime = q.rotate(v)\n...     print(v_prime)\n...\n[ 0.  0.  1.]\n[ 0.14213118 -0.12416109  0.98202991]\n[ 0.29457011 -0.22365854  0.92908843]\n[ 0.44909878 -0.29312841  0.84402963]\n[ 0.59738651 -0.32882557  0.73143906]\n[ 0.73143906 -0.32882557  0.59738651]\n[ 0.84402963 -0.29312841  0.44909879]\n[ 0.92908843 -0.22365854  0.29457012]\n[ 0.98202991 -0.12416109  0.14213118]\n[ 1. 0.  0.]\n\n\n\nIn the code above, the expression \nQuaternion.intermediates(q0, q1, 8, include_endpoints=True)\n returns an iterator over a sequence of Quaternion objects describing a set of 10 (8 + 2) rotations between \nq0\n and \nq1\n. The printed output is then the path of the point originally at [0, 0, 1] as it is rotated through 120 degrees about x=y=z to end up at [1, 0, 0].\nThis could easily be plugged into a visualisation framework to show smooth animated rotation sequences. Read the full documentation on interpolation features \nhere\n.\n\n\nFor a full demonstration of 3D interpolation and animation, run the \ndemo2.py\n script included in the pyquaternion package. This will require some elements of the full \nSciPy\n package that are not required for pyquaternion itself.\n\n\nObject Initialisation\n\n\nA Quaternion object can be created in the following ways:\n\n\nDefault\n\n\n\n\nQuaternion()\n\n\n\n\nCreates a unit quaternion \n1 + 0i + 0j + 0k\n: the quaternion representation of the real number 1.0, \nand the representation of a null rotation.\n\n\nq1 = Quaternion()\n\n\n\nFor the purposes of rotation, this is a null quaternion (has no effect on the rotated vector).\nFor the purposes of quaternion multiplication, this is a unit quaternion (has no effect when multiplying)\n\n\nCopy\n\n\n\n\nQuaternion(other)\n\n\n\n\nClone another quaternion object\n\n\nParams:\n\n\n\n\nother\n must be another Quaternion instance.\n\n\n\n\nq2 = Quaternion(q1)\n\n\n\n\nRaises:\n \nTypeError\n if the provided object is not an instance of Quaternion, or any valid positional argument as outlined below.\n\n\nRandom\n\n\n\n\nQuaternion.random()\n\n\n\n\nCreate a random quaternion that describes a rotation randomly chosen from a uniform distribution across the rotation space. \nSource\n.\n\n\nThis is a class method and is called as a method of the class itself rather than on a particular instance.\n\n\nq3 = Quaternion.random() # called as a class method\n\n\n\nFrom scalar\n\n\n\n\nQuaternion(scalar)\n\n\n\n\nCreate the quaternion representation of a scalar (single real number) value.\n\n\nParams:\n\n\n\n\nscalar\n can be a real number, or a string representing a real number.\n\n\n\n\nThe imaginary part of the resulting quaternion will always be \n0i + 0j + 0k\n.\n\n\nq4 = Quaternion(4.7349)\nq4 = Quaternion(-3)\nq4 = Quaternion(\"4.7349\")\nq4 = Quaternion(\"98\")\n\n\n\nRaises:\n\n\n\n\nTypeError\n if the provided value cannot be converted to a real number.\n\n\nValueError\n if a provided string cannot be interpreted as a real number.\n\n\n\n\nFrom elements\n\n\n\n\nQuaternion(w, x, y, z)\n\n\n\n\nCreate a quaternion by specifying 4 real-numbered scalar elements.\n\n\nParams:\n\n\n\n\nw, x, y, z\n can be real numbers, strings representing real numbers, or a mixture of both.\n\n\n\n\nq5 = Quaternion(1, 1, 0, 0)\nq5 = Quaternion(\"1.0\", \"0\", \"\"0.347\"\", \"0.0\")\nq5 = Quaternion(\"1.76\", 0, 0, 0)\n\n\n\n\nRaises:\n\n\n\n\nTypeError\n if any of the provided values cannot be converted to a real number.\n\n\nValueError\n if any of the provided strings cannot be interpreted as a real number.\n\n\n\n\nFrom a numpy array\n\n\n\n\nQuaternion(array)\n\n\n\n\nCreate a quaternion from the elements of a 4-element Numpy array\n\n\nParams:\n\n\n\n\narray\n must be a 4-element numpy array containing real valued elements.\n\n\n\n\nThe elements \n[a, b, c, d]\n of the array correspond the the real, and each imaginary component respectively in the order \na + bi + cj + dk\n.\n\n\nq6 = Quaternion(numpy.array([a, b, c, d]))\n\n\n\nRaises:\n\n\n\n\nTypeError\n if any of the array contents cannot be converted to a real number.\n\n\nValueError\n if the array contains less/more than 4 elements\n\n\n\n\nFrom a sequence\n\n\n\n\nQuaternion(seq)\n\n\n\n\nCreate a quaternion object from an ordered sequence containing 4 real valued scalar elements\n\n\nParams:\n\n\n\n\nseq\n can be a list, a tuple, a generator or any iterable sequence containing 4 values, each convertible to a real number.\n\n\n\n\nThe sequential elements \na, b, c, d\n of the sequence correspond the the real, and each imaginary component respectively in the order \na + bi + cj + dk\n.\n\n\nq7 = Quaternion((a, b, c, d)) // from 4-tuple\nq7 = Quaternion([a, b, c, d]) // from list of 4\n\n\n\nRaises:\n\n\n\n\nTypeError\n  if any of the sequence contents cannot be converted to a real number.\n\n\nValueError\n if the sequence contains less/more than 4 elements\n\n\n\n\nExplicitly by element\n\n\n\n\nQuaternion(a=w, b=x, c=y, d=z)\n\n\n\n\nSpecify each element, using any sequence of ordered labels\n\n\nParams:\n\n\n\n\na=w, b=x, c=y, d=z\n can be real numbers, strings representing real numbers, or a mixture of both.\n\n\n\n\nq8a = Quaternion(a=1.0, b=0.0, c=0.0, d=0.0)\nq8a = Quaternion(w=1.0, x=0.0, y=0.0, z=0.0)\nq8a = Quaternion(a=1.0, i=0.0, j=0.0, k=0.0)\nq8a = Quaternion(q1=1.0, q2=0.0, q3=0.0, q4=0.0)\n\n\n\n\nRasises:\n Exception behaviour is the same as initialisation by element as described above.\n\n\nExplicitly by component\n\n\n\n\nQuaternion(scalar=s, vector=v)\n or \nQuaternion(real=r, imaginary=i)\n\n\n\n\nSpecify the scalar (real) and vector (imaginary) parts of the desired quaternion.\n\n\nParams:\n\n\n\n\nscalar=s\n or \nreal=r\n can be a real number, or a string representing a real number.\n\n\nvector=v\n or \nimaginary=i\n can be a sequence or numpy array containing 3 real numbers.\n\n\n\n\nEither component (but not both) may be absent, \nNone\n or empty, and will be assumed to be zero in that case.\n\n\nq8b = Quaternion(scalar=1.0, vector=(0.0, 0.0, 0.0)) // Using 3-tuple\nq8b = Quaternion(scalar=None, vector=[1.0, 0.0, 0.0]) // Using list\nq8b = Quaternion(vector=numpy.array([1.0, 0.0, 0.0])) // Using Numpy 3-array\n\nq8b = Quaternion(real=1.0, imaginary=(0.0, 0.0, 0.0)) // Using 3-tuple\nq8b = Quaternion(real=None, imaginary=[1.0, 0.0, 0.0]) // Using list\nq8b = Quaternion(imaginary=numpy.array([1.0, 0.0, 0.0])) // Using Numpy 3-array\n\n\n\nRaises:\n \nValueError\n if the \nvector\n or \nimaginary\n component contains less/more than 3 elements\n\n\nExplicitly by rotation parameters\n\n\n\n\nQuaternion(axis=ax, radians=rad)\n or \nQuaternion(axis=ax, degrees=deg)\n or \nQuaternion(axis=ax, angle=theta)\n\n\n\n\nSpecify the angle (qualified as radians or degrees) for a rotation about an axis vector [x, y, z] to be described by the quaternion object.\n\n\nParams\n\n\n \naxis=ax\n can be a sequence or numpy array containing 3 real numbers. It can have any magnitude except \n0\n.\n\n \nradians=rad\n [optional] a real number, or a string representing a real number in radians.\n\n \ndegrees=deg\n [optional] a real number, or a string representing a real number in degrees.\n\n \nangle=theta\n [optional] a real number, or a string representing a real number in radians.\n\n\nThe \nangle\n (radians/degrees/angle) keyword may be absent, \nNone\n or empty, and will be assumed to be zero in that case,\nbut the \naxis\n keyword must be provided to describe a meaningful rotation.\n\n\nq8c = Quaternion(axis=(1.0, 0.0, 0.0), radians=math.pi/2) // Using radians asnd a 3-tuple\nq8c = Quaternion(axis=[1.0, 0.0, 0.0], degrees=90) // Using degrees and a list\nq8c = Quaternion(axis=numpy.array([1.0, 0.0, 0.0]), angle=math.pi/2) // Using radians and a Numpy 3-array\n\n\n\nRaises:\n\n\n\n\nValueError\n if \naxis\n is missing\n\n\nValueError\n if \naxis\n contains less/more than 3 elements\n\n\nTypeError\n if \nradians/degrees/angle\n cannot be interpreted as a real number\n\n\nZeroDivisionError\n if \naxis\n has 0 length.\n\n\n\n\nExplicitly by rotation or transformation matrix\n\n\n\n\nQuaternion(matrix=R)\n or \nQuaternion(matrix=T)\n\n\n\n\nSpecify the 3x3 rotation matrix (\nR\n) or 4x4 transformation matrix (\nT\n) from which the quaternion's rotation should be created.\n\n\nParams:\n\n\n\n\nmatrix=R\n can be a 3x3 numpy array or matrix\n\n\nmatrix=T\n can be a 4x4 numpy array or matrix. In this case, the translation part will be ignored, and only the rotational component of the matrix will be encoded within the quaternion.\n\n\n\n\nImportant:\n The rotation component of the provided matrix must be a pure rotation i.e. \nspecial orthogonal\n.\n\n\nrotation = numpy.eye(3)\ntransformation = numpy.eye(4)\nq8d = Quaternion(matrix=rotation) // Using 3x3 rotation matrix\nq8d = Quaternion(matrix=transformation) // Using 4x4 transformation matrix\n\n\n\nThis code uses a modification of the algorithm described in \nConverting a Rotation Matrix to a Quaternion\n, which is itself based on the method described \nhere\n.\n\n\nNote:\n Both matrices and quaternions avoid the singularities and discontinuities involved with rotation in 3 dimensions by adding extra dimensions. This has the effect that different values could represent the same rotation, for example quaternion q and -q represent the same rotation. It is therefore possible that, when converting a rotation sequence, the output may jump between these equivalent forms. This could cause problems where subsequent operations such as differentiation are done on this data. Programmers should be aware of this issue.\n\n\nRaises:\n\n\n\n\nValueError\n if the matrix is not 3x3 or 4x4 or if the matrix is not special orthogonal.\n\n\nTypeError\n if the matrix is of the wrong type\n\n\n\n\nExplicitly by a numpy array\n\n\n\n\nQuaternion(array=a)\n\n\n\n\nSpecify a numpy 4-array of quaternion elements to be assigned directly to the internal vector representation of the quaternion object.\n\n\nThis is more direct, and may be faster than feeding a numpy array as a positional argument to the initialiser.\n\n\nParams:\n\n\n\n\narray=a\n must be a 4-element numpy array containing real valued elements.\n\n\n\n\nThe elements \n[a, b, c, d]\n of the array correspond the the real, and each imaginary component respectively in the order \na + bi + cj + dk\n.\n\n\nq8e = Quaternion(array=numpy.array([1.0, 0.0, 0.0, 0.0]))\n\n\n\nRaises:\n \nValueError\n if the array vector contains less/more than 4 elements\n\n\nQuaternion Features\n\n\nThis section defines features available for pyquaternion's Quaternion objects\n\n\nThe code examples below assume the existence of a Quaternion object. You can recreate this by running the following in your Python interpreter of choice:\n\n\nmy_quaternion = Quaternion.random()\n\n\n\nNorm\n\n\n\n\nnorm\n or \nmagnitude\n\n\n\n\nL2 norm of the quaternion 4-vector\n\n\nThis should be 1.0 for a unit quaternion (versor)\n\n\nReturns:\n a scalar real number representing the square root of the sum of the squares of the elements of the quaternion.\n\n\nmy_quaternion.norm\nmy_quaternion.magnitude\n\n\n\n\n\nis_unit(tolerance=1e-14)\n\n\n\n\nParams:\n\n\n\n\ntolerance\n - [optional] - maximum absolute value by which the norm can differ from 1.0 for the object to be considered a unit quaternion. Defaults to \n1e-14\n.\n\n\n\n\nReturns:\n \nTrue\n if the Quaternion object is of unit length to within the specified tolerance value. \nFalse\n otherwise.\n\n\nInversion\n\n\n\n\ninverse\n\n\n\n\nInverse of the quaternion object\n\n\nFor a unit quaternion, this is the inverse rotation, i.e. when combined with the original rotation, will result in the null rotation.\n\n\nReturns:\n a new Quaternion object representing the inverse of this object\n\n\ninv_quaternion = my_quaternion.inverse\n\n\n\nConjugation\n\n\n\n\nconjugate\n\n\n\n\nQuaternion conjugate\n\n\nFor a unit quaternion, this is the same as the inverse.\n\n\nReturns:\n a new Quaternion object clone with its vector part negated\n\n\nconj_quaternion = my_quaternion.conjugate\n\n\n\nNormalisation\n\n\n\n\nnormalised\n or \nunit\n\n\n\n\nGet a unit quaternion (versor) copy of this Quaternion object.\n\n\nA unit quaternion has a \nnorm\n of 1.0\n\n\nNote:\n A Quaternion representing zero i.e. \nQuaternion(0, 0, 0, 0)\n cannot be normalised. In this case, the returned object will remain zero.\n\n\nReturns:\n a new Quaternion object clone that is guaranteed to be a unit quaternion \nunless\n the original object was zero, in which case the norm will remain zero.\n\n\nunit_quaternion = my_quaternion.normalised\nunit_quaternion = my_quaternion.unit\n\n\n\nRotation\n\n\n\n\nrotate(vector)\n\n\n\n\nRotate a 3D vector by the rotation stored in the Quaternion object\n\n\nParams:\n\n\n\n\nvector\n - a 3-vector specified as any ordered sequence of 3 real numbers corresponding to x, y, and z values. Some types that are recognised are: numpy arrays, lists and tuples. A 3-vector can also be represented by a Quaternion object who's scalar part is 0 and vector part is the required 3-vector. Thus it is possible to call \nQuaternion.rotate(q)\n with another quaternion object as an input.\n\n\n\n\nReturns:\n the rotated vector returned as the same type it was specified at input.\n\n\nrotated_tuple       = my_quaternion.rotate((1, 0, 0)) # Returns a tuple\nrotated_list        = my_quaternion.rotate([1.0, 0.0, 0.0]) # Returns a list\nrotated_array       = my_quaternion.rotate(numpy.array([1.0, 0.0, 0.0])) # Returns a Numpy 3-array\nrotated_quaternion  = my_quaternion.rotate(Quaternion(vector=[1, 0, 0])) # Returns a Quaternion object\n\n\n\nRaises:\n\n\n\n\nTypeError\n if any of the vector elements cannot be converted to a real number.\n\n\nValueError\n if \nvector\n cannot be interpreted as a 3-vector or a Quaternion object.\n\n\n\n\nExp and Log Maps\n\n\n\n\nQuaternion.exp(q)\n - \nclass method\n\n\n\n\nQuaternion Exponential.\n\n\nParams:\n\n\n\n\nq\n - the input quaternion/argument as a Quaternion object.\n\n\n\n\nReturns:\n A quaternion amount representing the exp(q). See \nSource\n.\n\n\nNote:\n The method can compute the exponential of any quaternion.\n\n\n\n\nQuaternion.log(q)\n - \nclass method\n\n\n\n\nQuaternion Logarithm.\n\n\nParams:\n\n\n\n\nq\n - the input quaternion/argument as a Quaternion object.\n\n\n\n\nReturns:\n A quaternion amount representing \nlog(q) := (log(|q|), v/|v|acos(w/|q|))\n.\n\n\nNote:\n The method computes the logarithm of general quaternions. See \nSource\n for more details.\n\n\n\n\nQuaternion.exp_map(q, eta)\n - \nclass method\n\n\n\n\nQuaternion exponential map.\n\n\nFind the exponential map on the Riemannian manifold described by the quaternion space.\n\n\nParams:\n\n\n\n\nq\n - the base point of the exponential map, i.e. a Quaternion object\n\n\neta\n -  the argument of the exponential map, a tangent vector, i.e. a Quaternion object\n\n\n\n\nReturns:\n A quaternion p such that p is the endpoint of the geodesic starting at q in the direction of eta, having the length equal to the magnitude of eta.\n\n\nNote:\n The exponential map plays an important role in integrating orientation variations (e.g. angular velocities). This is done by projecting quaternion tangent vectors onto the quaternion manifold.\n\n\n\n\nQuaternion.sym_exp_map(q, eta)\n - \nclass method\n\n\n\n\nQuaternion symmetrized exponential map.\n\n\nFind the symmetrized exponential map on the quaternion Riemannian manifold.\n\n\nParams:\n\n\n\n\nq\n - the base point as a Quaternion object\n\n\neta\n - the tangent vector argument of the exponential map as a Quaternion object\n\n\n\n\nReturns:\n A quaternion p.\n\n\nNote:\n The symmetrized exponential formulation is akin to the exponential formulation for symmetric positive definite tensors \nSource\n\n\n\n\nQuaternion.log_map(q, p)\n - \nclass method\n\n\n\n\nQuaternion logarithm map.\n\n\nFind the logarithm map on the quaternion Riemannian manifold.\n\n\nParams:\n\n\n\n\nq\n - the base point at which the logarithm is computed, i.e. a Quaternion object\n\n\np\n - the argument of the quaternion map, a Quaternion object\n\n\n\n\nReturns:\n A tangent vector having the length and direction given by the geodesic joining q and p.\n\n\n\n\nQuaternion.sym_log_map(q, p)\n - \nclass method\n\n\n\n\nQuaternion symmetrized logarithm map.\n\n\nFind the symmetrized logarithm map on the quaternion Riemannian manifold.\n\n\nParams:\n\n\n\n\nq\n - the base point at which the logarithm is computed, i.e. a Quaternion object\n\n\np\n - the argument of the quaternion map, a Quaternion object\n\n\n\n\nReturns:\n A tangent vector corresponding to the symmetrized geodesic curve formulation.\n\n\nNote:\n Information on the symmetrized formulations given in \nSource\n.\n\n\nDistance computation\n\n\n\n\nQuaternion.absolute_distance(q0, q1)\n - \nclass method\n\n\n\n\nQuaternion absolute distance.\n\n\nFind the distance between two quaternions accounting for the sign ambiguity.\n\n\nParams:\n\n\n\n\nq0\n - the first quaternion\n\n\nq1\n - the second quaternion\n\n\n\n\nReturns:\n  A positive scalar corresponding to the chord of the shortest path/arc that connects q0 to q1.\n\n\nNote:\n This function does not measure the distance on the hypersphere, but it takes into account the fact that q and -q encode the same rotation. It is thus a good indicator for rotation similarities.\n\n\n\n\nQuaternion.distance(q0, q1)\n - \nclass method\n\n\n\n\nQuaternion intrinsic distance.\n\n\nFind the intrinsic geodesic distance between q0 and q1.\n\n\nParams:\n\n\n\n\nq0\n - the first quaternion\n\n\nq1\n - the second quaternion\n\n\n\n\nReturns:\n A positive amount corresponding to the length of the geodesic arc connecting q0 to q1.\n\n\nNote:\n Although \nq0^(-1)*q1 != q1^(-1)*q0\n, the length of the path joining them is given by the logarithm of those product quaternions, the norm of which is the same.\n\n\n\n\nQuaternion.sym_distance(q0, q1)\n - \nclass method\n\n\n\n\nQuaternion symmetrized distance.\n\n\nFind the intrinsic symmetrized geodesic distance between q0 and q1.\n\n\nParams:\n\n\n\n\nq0\n - the first quaternion\n\n\nq1\n - the second quaternion\n\n\n\n\nReturns:\n A positive amount corresponding to the length of the symmetrized geodesic curve connecting q0 to q1.\n\n\nNote:\n This formulation is more numerically stable when performing iterative gradient descent on the Riemannian quaternion manifold.\nHowever, the distance between q and -q is equal to pi, rendering this formulation not useful for measuring rotation similarities when the samples are spread over a \"solid\" angle of more than pi/2 radians (the spread refers to quaternions as point samples on the unit hypersphere).\n\n\nInterpolation\n\n\n\n\nQuaternion.slerp(q0, q1, amount=0.5)\n - \nclass method\n\n\n\n\nFind a valid quaternion rotation at a specified distance along the minor arc of a great circle passing through any two existing quaternion endpoints lying on the unit radius hypersphere. \nSource\n\n\nThis is a class method and is called as a method of the class itself rather than on a particular instance.\n\n\nParams:\n\n\n\n\nq0\n - first endpoint rotation as a Quaternion object\n\n\nq1\n - second endpoint rotation as a Quaternion object\n\n\namount\n - interpolation parameter between 0 and 1. This describes the linear placement position of the result along the arc between endpoints; 0 being at \nq0\n and 1 being at \nq1\n. Defaults to the midpoint (0.5).\n\n\n\n\nReturns:\n\na new Quaternion object representing the interpolated rotation. This is guaranteed to be a unit quaternion.\n\n\nNote:\n This feature only makes sense when interpolating between unit quaternions (those lying on the unit radius hypersphere). Calling this method will implicitly normalise the endpoints to unit quaternions if they are not already unit length.\n\n\nq0 = Quaternion(axis=[1, 1, 1], angle=0.0)\nq1 = Quaternion(axis=[1, 1, 1], angle=3.141592)\nq  = Quaternion.slerp(q0, q1, 2.0/3.0) # Rotate 120 degrees (2 * pi / 3)\n\n\n\n\n\nQuaternion.intermediates(q_start, q_end, n, include_endpoints=False)\n - \nclass method\n\n\n\n\nGenerator method to get an iterable sequence of \nn\n evenly spaced quaternion rotations between any two existing quaternion endpoints lying on the unit radius hypersphere. This is a convenience function that is based on \nQuaternion.slerp()\n as defined above.\n\n\nThis is a class method and is called as a method of the class itself rather than on a particular instance.\n\n\nParams:\n\n\n\n\nq_start\n - initial endpoint rotation as a Quaternion object\n\n\nq_end\n - final endpoint rotation as a Quaternion object\n\n\nn\n - number of intermediate quaternion objects to include within the interval\n\n\ninclude_endpoints\n - [optional] - If set to \nTrue\n, the sequence of intermediates will be 'bookended' by \nq_start\n and \nq_end\n, resulting in a sequence length of \nn + 2\n. If set to \nFalse\n, endpoints are not included. Defaults to \nFalse\n.\n\n\n\n\nYields:\n\na generator object iterating over a sequence of intermediate quaternion objects.\n\n\nNote:\n This feature only makes sense when interpolating between unit quaternions (those lying on the unit radius hypersphere). Calling this method will implicitly normalise the endpoints to unit quaternions if they are not already unit length.\n\n\nq0 = Quaternion(axis=[1, 1, 1], angle=0.0)\nq1 = Quaternion(axis=[1, 1, 1], angle=2 * 3.141592 / 3)\nfor q in Quaternion.intermediates(q0, q1, 8, include_endpoints=True):\n    v = q.rotate([1, 0, 0])\n    print(v)\n\n\n\nDifferentiation\n\n\n\n\nderivative(rate)\n\n\n\n\nGet the instantaneous quaternion derivative representing a quaternion rotating at a 3D rate vector \nrate\n\n\nParams:\n\n\n\n\nrate\n - numpy 3-array (or array-like) describing rotation rates about the global x, y and z axes respectively.\n\n\n\n\nReturns:\n A unit quaternion describing the rotation rate\n\n\nq_dot = my_quaternion.derivative([0, 0, 3.14159]) # Rotate about z at 0.5 rotation per second\n\n\n\nRaises:\n\n\n\n\nTypeError\n  if any of \nrate\n contents cannot be converted to a real number.\n\n\nValueError\n if \nrate\n contains less/more than 3 elements\n\n\n\n\nIntegration\n\n\n\n\nintegrate(rate, timestep)\n\n\n\n\nAdvance a time varying quaternion to its value at a time \ntimestep\n in the future.\n\n\nThe Quaternion object will be modified to its future value. It is guaranteed to remain a unit quaternion.\n\n\nParams:\n\n\n\n\nrate\n - numpy 3-array (or array-like) describing rotation rates about the global x, y and z axes respectively.\n\n\ntimestep\n - interval over which to integrate into the future. Assuming \nnow\n is \nT=0\n, the integration occurs over the interval \nT=0\n to \nT=timestep\n. Smaller intervals are more accurate when \nrate\n changes over time.\n\n\n\n\nNote 1:\n This feature only makes sense when referring to a unit quaternion. Calling this method will implicitly normalise the Quaternion object to a unit quaternion if it is not already one. Many quaternion integration algorithms will have unwanted scaling effects leading a quaternion object to become non-unit over time, thus the object is re-normalised with each call to \nintegrate()\n. Because this method is often called very frequently (every \ntimestep\n for realtime simulation) an optimised re-normalisation is performed. See \n_fast_normalise()\n for more info.\n\n\nNote 2:\n The solution is in closed form given the assumption that \nrate\n is constant over the interval of length \ntimestep\n. This algorithm is not an exact solution to the differential equation over any interval where the angular rates are not constant. It is a second order approximation, meaning the integral error contains terms proportional to \ntimestep ** 3\n and higher powers.\n\n\n>>> q = Quaternion() # null rotation\n>>> q.integrate([2*pi, 0, 0], 0.25) # Rotate about x at 1 rotation per second\n>>> q == Quaternion(axis=[1, 0, 0], angle=(pi/2))\nTrue\n>>>\n\n\n\nRaises:\n\n\n\n\nTypeError\n  if any of \nrate\n contents cannot be converted to a real number.\n\n\nValueError\n if \nrate\n contains less/more than 3 elements\n\n\n\n\nAccessing matrix form\n\n\n\n\nrotation_matrix\n & \ntransformation_matrix\n\n\n\n\nGet the 3x3 rotation or 4x4 homogeneous transformation matrix equivalent of the quaternion rotation.\n\n\nReturns:\n\n\n\n\nQuaternion.rotation_matrix\n : a 3x3 orthogonal rotation matrix as a 3x3 Numpy array\n\n\nQuaternion.transformation_matrix\n : a 4x4 homogeneous transformation matrix as a 4x4 Numpy array\n\n\n\n\nNote 1:\n This feature only makes sense when referring to a unit quaternion. Calling this method will implicitly normalise the Quaternion object to a unit quaternion if it is not already one.\n\n\nNote 2:\n Both matrices and quaternions avoid the singularities and discontinuities involved with rotation in 3 dimensions by adding extra dimensions. This has the effect that different values could represent the same rotation, for example quaternion q and -q represent the same rotation. It is therefore possible that, when converting a rotation sequence, the output may jump between different but equivalent forms. This could cause problems where subsequent operations such as differentiation are done on this data. Programmers should be aware of this issue.\n\n\nR = my_quaternion.rotation_matrix         # 3x3 rotation matrix\nT = my_quaternion.transformation_matrix   # 4x4 transformation matrix\n\n\n\nAccessing rotation axis\n\n\n\n\naxis\n or \nget_axis(undefined=[0,0,0])\n\n\n\n\nGet the axis or vector about which the quaternion rotation occurs\n\n\nFor a null rotation (a purely real quaternion), the rotation angle will always be \n0\n, but the rotation axis is undefined. It is by default assumed to be \n[0, 0, 0]\n.\n\n\nNote:\n In the case of a null rotation, retrieving the axis is geometrically meaningless, as it could be any of an infinite set of vectors.\nBy default, (\n[0, 0, 0]\n) is returned in this instance, but should this causes undesired behaviour, please use the\nalternative \nget_axis()\n form, specifying the \nundefined\n keyword to return a vector of your choice.\n\n\nParams:\n\n\n\n\nundefined\n - [optional] - specify the axis vector that should define a null rotation. \n\n\n\n\nReturns:\n a Numpy unit 3-vector describing the Quaternion object's axis of rotation.\n\n\nNote 1:\n This feature only makes sense when referring to a unit quaternion. Calling this method will implicitly normalise the Quaternion object to a unit quaternion if it is not already one.\n\n\nNote 2:\n Both matrices and quaternions avoid the singularities and discontinuities involved with rotation in 3 dimensions by adding extra dimensions. This has the effect that different values could represent the same rotation, for example quaternion q and -q represent the same rotation. It is therefore possible that, when converting a rotation sequence to axis/angle representation, the output may jump between different but equivalent forms. This could cause problems where subsequent operations such as differentiation are done on this data. Programmers should be aware of this issue.\n\n\nu = my_quaternion.axis # Unit vector about which rotation occurs  #or \nu = my_quaternion.get_axis(undefined=[1, 0, 0]) # Prefers a custom axis vector in the case of undefined result\n\n\n\nAccessing rotation angle\n\n\n\n\nangle\n, \ndegrees\n or \nradians\n\n\n\n\nGet the angle (in radians) describing the magnitude of the quaternion rotation about its rotation axis. This is guaranteed to be within the range (-pi:pi) with the direction of rotation indicated by the sign.\n\n\nWhen a particular rotation describes a 180 degree rotation about an arbitrary axis vector \nv\n, the conversion to axis / angle representation may jump discontinuously between all permutations of \n(-pi, pi)\n and \n(-v, v)\n, each being geometrically equivalent (see Note 2 below).\n\n\nReturns:\n a real number in the range (-pi:pi) describing the angle of rotation in radians about a Quaternion object's axis of rotation.\n\n\nNote 1:\n This feature only makes sense when referring to a unit quaternion. Calling this method will implicitly normalise the Quaternion object to a unit quaternion if it is not already one.\n\n\nNote 2:\n Both matrices and quaternions avoid the singularities and discontinuities involved with rotation in 3 dimensions by adding extra dimensions. This has the effect that different values could represent the same rotation, for example quaternion q and -q represent the same rotation. It is therefore possible that, when converting a rotation sequence to axis/angle representation, the output may jump between different but equivalent forms. This could cause problems where subsequent operations such as differentiation are done on this data. Programmers should be aware of this issue.\n\n\ntheta = my_quaternion.angle # Magnitude of rotation about the prescribed axis, in radians\ntheta = my_quaternion.radians # Equivalent, but explicit\ntheta = my_quaternion.degrees # The same, but in degrees\n\n\n\nAccessing real components\n\n\n\n\nscalar\n or \nreal\n\n\n\n\nGet the real or scalar component of the Quaternion object\n\n\nA quaternion can be described in terms of a scalar and vector part, q = [r, \nv\n] where:\n\n\n\n\nr is the scalar coefficient of the real part of the quaternion i.e. \na\n in a + b\ni\n + c\nj\n + d\nk\n\n\nv\n is the 3-vector of coefficients to the imaginary parts of the quaternion i.e. [b, c, d] in a + b\ni\n + c\nj\n + d\nk\n\n\n\n\nThis property returns r\n\n\nReturns\n the scalar, real valued element of the Quaternion object\n\n\nr = my_quaternion.scalar\nr = my_quaternion.real\n\n\n\nAccessing imaginary components\n\n\n\n\nvector\n or \nimaginary\n\n\n\n\nGet the imaginary or vector component of the Quaternion object. This can be used, for example, to extract the stored vector when a pure-imaginary quaternion object is used to describe a vector within the three-dimensional vector space.\n\n\nA quaternion can be described in terms of a scalar and vector part, q = [r, \nv\n] where:\n\n\n\n\nr is the scalar coefficient of the real part of the quaternion i.e. \na\n in a + b\ni\n + c\nj\n + d\nk\n\n\nv\n is the 3-vector of coefficients to the imaginary parts of the quaternion i.e. [b, c, d] in a + b\ni\n + c\nj\n + d\nk\n\n\n\n\nThis property returns \nv\n\n\nReturns\n Numpy 3-array of the 3 imaginary elements of the Quaternion object\n\n\nv = my_quaternion.vector\nv = my_quaternion.imaginary\n\n\n\nAccessing individual elements\n\n\n\n\nelements\n\n\n\n\nReturn all four elements of the quaternion object. Result is not guaranteed to be a unit 4-vector.\n\n\nReturns:\n a numpy 4-array of real numbered coefficients.\n\n\n>>> a = my_quaternion.elements\n>>> print(\"{} + {}i + {}j + {}k\".format(a[0], a[1], a[2], a[3]))\n    -0.6753741977725701 + 0.4624451782281068i + -0.059197245808339134j + 0.5714103921047806k\n\n\n\n\n\n__getitem__(index)\n\n\n\n\nmy_quaternion[i]\n returns the real numbered element at the specified index \ni\n in the quaternion 4-array\n\n\nParams:\n\n\n\n\nindex\n - integer in the range [-4:3] inclusive\n\n\n\n\n>>> print(\"{} + {}i + {}j + {}k\".format(my_quaternion[0], my_quaternion[1], my_quaternion[2], my_quaternion[3]))\n   -0.6753741977725701 + 0.4624451782281068i + -0.059197245808339134j + 0.5714103921047806k\n>>> print(\"{} + {}i + {}j + {}k\".format(my_quaternion[-4], my_quaternion[-3], my_quaternion[-2], my_quaternion[-1]))\n   -0.6753741977725701 + 0.4624451782281068i + -0.059197245808339134j + 0.5714103921047806k\n>>>\n\n\n\n\nRaises:\n\n\n\n\nIndexError\n if the index provided is invalid\n\n\nTypeError\n or \nValueError\n if the index cannot be interpreted as an integer\n\n\n\n\nModifying individual elements\n\n\n\n\n__setitem__(index, value)\n\n\n\n\nmy_quaternion[i] = x\n sets the element at the specified index \ni\n in the quaternion 4-array to the specified value \nx\n.\n\n\nParams:\n\n\n\n\nindex\n - integer in the range [-4:3] inclusive\n\n\nvalue\n - real value to be inserted into the quaternion array at \nindex\n\n\n\n\n>>> str(my_quaternion)\n    '-0.653 -0.127i -0.220j +0.714k'\n>>> my_quaternion[2] = 9\n>>> str(my_quaternion)\n    '-0.653 -0.127i +9.000j +0.714k'\n>>>\n\n\n\n\nRaises:\n\n\n\n\nIndexError\n if the index provided is invalid\n\n\nTypeError\n or \nValueError\n if the value cannot be interpreted as a real number\n\n\n\n\nQuaternion Operations\n\n\nThis section defines operations applicable to pyquaternion's Quaternion objects.\n\n\nThe code examples below assume the existence of a Quaternion object. You can recreate this by running the following in your Python interpreter of choice:\n\n\nmy_quaternion = Quaternion.random()\n\n\n\nString Representation\n\n\n\n\n__str__()\n\n\n\n\nstr(my_quaternion)\n returns an informal, nicely printable string representation of the Quaternion object. \nSource\n\n\n>>> str(my_quaternion)\n    '-0.810 +0.022i -0.563j -0.166k'\n>>> print(my_quaternion)\n    -0.810 +0.022i -0.563j -0.166k\n>>>\n\n\n\n\n\n__repr__()\n\n\n\n\nrepr(my_quaternion)\n returns the 'official' string representation of the Quaternion object.  This is a string representation of a valid Python expression that could be used to recreate an object with the same value (given an appropriate environment). \nSource\n\n\n>>> repr(my_quaternion)\n    'Quaternion(-0.80951530224438595, 0.022231097065902788, -0.56268832802625091,-0.16604999023923223)'\n>>> my_quaternion\n    Quaternion(-0.80951530224438595, 0.022231097065902788, -0.56268832802625091,-0.16604999023923223)\n>>>\n\n\n\n\n\n__format__(format_spec)\n\n\n\n\na_string_containing_{format_spec}_placeholders.format(my_quaternion)\n inserts a customisable, nicely printable string representation of the Quaternion object into the respective places in the provided string. \nSource\n\n\nThe syntax for \nformat_spec\n mirrors that of the built in format specifiers for floating point types. Check out the official Python \nformat specification mini-language\n for details.\nAn empty \nformat_spec\n string will result in the same behaviour as the \nQuaternion.__str__()\n.\n\n\n>>> \"My quaternion is: {}\".format(my_quaternion)\n    'My quaternion is: -0.810 +0.022i -0.563j -0.166k'\n>>> \"My quaternion is: {:+.6}\".format(my_quaternion)\n    'My quaternion is: -0.809515 +0.0222311i -0.562688j -0.16605k'\n\n\n\nBool\n\n\n\n\n__bool__()\n or \n__nonzero__()\n\n\n\n\nReturns:\n \nFalse\n within a logical context if the Quaternion object is zero, i.e. \nQuaternion(0.0, 0.0, 0.0, 0.0)\n or \nTrue\n otherwise.\n\n\nThe bitwise not operator \n~\n can be used to invert the boolean value, however the keyword \nnot\n (logical) is preferred.\n\n\nNote:\n This does not evaluate the booleanity of a quaternion rotation. A non-zero Quaternion object such as \nQuaternion(1.0, 0.0, 0.0, 0.0)\n will have a boolean value of \nTrue\n even though it represents a \nnull\n rotation.\n\n\n>>> Quaternion() == True\nTrue\n>>> not Quaternion() == False\nTrue\n>>> Quaternion(scalar=0.0) == False\nTrue\n\n\n\nEquality\n\n\n\n\n__eq__(other)\n\n\n\n\nq1 == q2\n returns \nTrue\n if all corresponding elements are equal between two Quaternion objects \nq1\n and \nq2\n, or \nFalse\n otherwise.\n\n\nThe inequality operator \n!=\n can also be used to verify inequality in a similar way.\n\n\nBecause comparisons are carried out on floating point elements, equality is considered \nTrue\n when the absolute difference between elements falls below a threshold error. This is determined by \nnumpy.allclose()\n with an absolute tolerance of \n1.0e-14\n and a relative tolerance of \n1.0e-13\n. As a result, objects differing by very small individual element differences may be considered equal.\n\n\nNote:\n This does not directly evaluate the equality of a quaternion rotation. For example, unit Quaternions q and -q will have an equality of \nFalse\n even though they represent the equivalent rotation.\n\n\n>>> Quaternion(1, 0, 1, 1) == Quaternion(scalar=1.0, vector=[0.0, 1.0, 1.0])\nTrue\n>>> Quaternion(1, 0, 1, 1) == Quaternion(scalar=1.0, vector=[0.1, 1.0, 1.0])\nFalse\n>>> Quaternion() != Quaternion(scalar=2)\nTrue\n\n\n\nNegation\n\n\n\n\n__neg__()\n\n\n\n\n-q\n is the quaternion formed by the element wise negation of the elements of \nq\n.\n\n\nReturns:\n a new Quaternion object representing the negation of the single operand.\nIf the operand is a unit quaternion, the result is guaranteed to be a unit quaternion.\n\n\n>>> my_elements = my_quaternion.elements() # Numpy array of individual elements\n>>> -my_quaternion == Quaternion(-my_elements)\nTrue\n\n\n\nAddition\n\n\n\n\n__add__(other)\n\n\n\n\nq1 + q2\n is the quaternion formed by element-wise sum of \nq1\n and \nq2\n. \nSource\n\n\nNote:\n If 'other' is not a Quaternion object, it will be converted to one, using the behaviour described in the [object initialisation][initialisation] section. As described therein, a \nTypeError\n or \nValueError\n will be raised if this conversion fails.\n\n\nReturns:\n a new Quaternion object representing the sum of the inputs.\nThe sum is \nnot\n guaranteed to be a unit quaternion.\n\n\n>>> q1 = Quaternion.random()\n>>> q2 = Quaternion.random()\n>>> q1 + q2 == Quaternion(q1.elements() + q2.elements())\nTrue\n\n\n\nSubtraction\n\n\n\n\n__sub__(other)\n\n\n\n\nq1 - q2\n is the quaternion formed by element-wise difference between \nq1\n and \nq2\n. \nSource\n\n\nNote:\n If 'other' is not a Quaternion object, it will be converted to one, using the behaviour described in the [object initialisation][initialisation] section. As described therein, a \nTypeError\n or \nValueError\n will be raised if this conversion fails.\n\n\nReturns:\n a new Quaternion object representing the difference of the inputs.\nThe difference is \nnot\n guaranteed to be a unit quaternion.\n\n\n>>> q1 = Quaternion.random()\n>>> q2 = Quaternion.random()\n>>> q1 - q2 == Quaternion(q1.elements() - q2.elements())\nTrue\n\n\n\nMultiplication\n\n\n\n\n__mul__(other)\n\n\n\n\nq1 * q2\n is the quaternion formed by Hamilton product of \nq1\n and \nq2\n. \nSource\n\n\nThe Hamiltonian product is not commutative. Ensure your operands are correctly placed.\n\n\nNote:\n If 'other' is not a Quaternion object, it will be converted to one, using the behaviour described in the [object initialisation][initialisation] section. As described therein, a \nTypeError\n or \nValueError\n will be raised if this conversion fails. As a result this operation holds true for scalar multiplication as scalars are converted to pure real Quaternion objects.\n\n\nReturns:\n a new Quaternion object representing the Hamilton product of the inputs.\nIf the two multiplicands are unit quaternions, the product is guaranteed to be a unit quaternion.\n\n\n>>> one = Quaternion(1, 0, 0, 0)\n>>> i   = Quaternion(0, 1, 0, 0)\n>>> j   = Quaternion(0, 0, 1, 0)\n>>> k   = Quaternion(0, 0, 0, 1)\n>>> (i * i) == (j * j) == (k * k) == (i * j * k) == -1\nTrue\n\n\n\nDivision\n\n\n\n\n__truediv__(other)\n or \n__div__(other)\n\n\n\n\nq1 / q2\n is the quaternion formed by Hamilton product of \nq1\n and \nq2.inverse()\n. \nSource\n\n\nThe Hamiltonian product is not commutative. Ensure your operands are correctly placed.\n\n\nNote:\n If 'other' is not a Quaternion object, it will be converted to one, using the behaviour described in the [object initialisation][initialisation] section. As described therein, a \nTypeError\n or \nValueError\n will be raised if this conversion fails. As a result this operation holds true for scalar division as scalars are converted to pure real Quaternion objects.\n\n\nReturns:\n a new Quaternion object representing the Hamilton quotient of the inputs.\nIf the dividend and divisor are unit quaternions, the quotient is guaranteed to be a unit quaternion.\n\n\n>>> my_quaternion / my_quaternion == Quaternion(1.0)\nTrue\n\n\n\nExponentiation\n\n\n\n\n__pow__(other)\n\n\n\n\nq ** p\n is the quaternion formed by raising the Quaternion \nq1\n to the power of \np\n for any real \np\n. \nSource\n\n\nReturns:\n a new Quaternion object representing the the object raised to the power of the input.\nIf the base object is a unit quaternion, the result is guaranteed to be a unit quaternion.\n\n\n>>> one = Quaternion(1, 0, 0, 0)\n>>> i   = Quaternion(0, 1, 0, 0)\n>>> j   = Quaternion(0, 0, 1, 0)\n>>> k   = Quaternion(0, 0, 0, 1)\n>>> (i ** 2) == (j ** 2) == (k ** 2) == -1\nTrue\n\n\n\nRaises:\n \nTypeError\n if \nother\n cannot be interpreted as a real number.",
            "title": "Home"
        },
        {
            "location": "/#welcome",
            "text": "Welcome! pyquaternion is a full-featured Python module for representing and using quaternions.  The following should get you up and running with pyquaternion in no time.",
            "title": "Welcome"
        },
        {
            "location": "/#getting-started",
            "text": "The following aims to familiarize you with the basic functionality of quaternions in pyquaternion. It provides an entry point and a quick orientation (no pun intended) for those who want get stuck straight in. More comprehensive feature summaries can be found in the  features  and  operations  documentation.  If you want to learn more about quaternions and how they apply to certain problems, you can read about quaternions  here , and their application to rotations  here .",
            "title": "Getting started"
        },
        {
            "location": "/#installation",
            "text": "To start, you will need to install  pyquaternion  into your environment.   [Optional] If you are using virtual environments, switch to or create your environment of choice now:  $ workon <my_environment>   Now use pip to install  pyquaternion  and its dependencies  $ pip install pyquaternion   Note: pyquaternion requires  Numpy  for the representation of arrays and matrices.\nChances are if you're needing quaternions, you've been dealing with numerical computation and you're already familiar with numpy.\nIf not, don't worry, it will be installed into your environment automatically.   Great, you now have pyquaternion installed and you're ready to roll. Or pitch. Or yaw. No judging here :)",
            "title": "Installation"
        },
        {
            "location": "/#basic-usage",
            "text": "In your code, simply import the  Quaternion  object from the  pyquaternion  module:  >>> from pyquaternion import Quaternion  Next, create a Quaternion object to describe your desired rotation:  >>> my_quaternion = Quaternion(axis=[1, 0, 0], angle=3.14159265)   Note: There are many ways to create a Quaternion object. See the  initialisation  section for a complete guide.   Now you can do a bunch of useful things with your new quaternion object. Let's try rotating a vector:  >>> import numpy\n>>> numpy.set_printoptions(suppress=True) # Suppress insignificant values for clarity\n>>> v = numpy.array([0., 0., 1.]) # Unit vector in the +z direction\n>>> v_prime = my_quaternion.rotate(v)\n>>> v_prime\n    array([ 0., 0., -1.])\n>>>  A cool feature of quaternions is that they can be intuitively chained together to form a composite rotation from a sequence of discrete rotations:  >>> q1 = Quaternion(axis=[1, 0, 0], angle=3.14159265) # Rotate 180 about X\n>>> q2 = Quaternion(axis=[0, 1, 0], angle=3.14159265 / 2) # Rotate 90 about Y\n>>> q3 = q1 * q2 # Composite rotation of q1 then q2 expressed as standard multiplication\n>>> v_prime = q3.rotate(v)\n>>> v_prime\n    array([ 1., 0., 0.])\n>>>  Quaternions are used extensively in animation to describe smooth transitions between known orientations. This is known as interpolation. This is an example of an area where quaternions are preferred to rotation matrices as smooth interpolation is not possible with the latter. Here's quaternion interpolation in action:  >>> import numpy\n>>> numpy.set_printoptions(suppress=True) # Suppress insignificant values for clarity\n>>> v = numpy.array([0., 0., 1.]) # Unit vector in the +z direction\n>>> q0 = Quaternion(axis=[1, 1, 1], angle=0.0) # Rotate 0 about x=y=z\n>>> q1 = Quaternion(axis=[1, 1, 1], angle=2 * 3.14159265 / 3) # Rotate 120 about x=y=z\n>>> for q in Quaternion.intermediates(q0, q1, 8, include_endpoints=True):\n...     v_prime = q.rotate(v)\n...     print(v_prime)\n...\n[ 0.  0.  1.]\n[ 0.14213118 -0.12416109  0.98202991]\n[ 0.29457011 -0.22365854  0.92908843]\n[ 0.44909878 -0.29312841  0.84402963]\n[ 0.59738651 -0.32882557  0.73143906]\n[ 0.73143906 -0.32882557  0.59738651]\n[ 0.84402963 -0.29312841  0.44909879]\n[ 0.92908843 -0.22365854  0.29457012]\n[ 0.98202991 -0.12416109  0.14213118]\n[ 1. 0.  0.]  In the code above, the expression  Quaternion.intermediates(q0, q1, 8, include_endpoints=True)  returns an iterator over a sequence of Quaternion objects describing a set of 10 (8 + 2) rotations between  q0  and  q1 . The printed output is then the path of the point originally at [0, 0, 1] as it is rotated through 120 degrees about x=y=z to end up at [1, 0, 0].\nThis could easily be plugged into a visualisation framework to show smooth animated rotation sequences. Read the full documentation on interpolation features  here .  For a full demonstration of 3D interpolation and animation, run the  demo2.py  script included in the pyquaternion package. This will require some elements of the full  SciPy  package that are not required for pyquaternion itself.",
            "title": "Basic Usage"
        },
        {
            "location": "/#object-initialisation",
            "text": "A Quaternion object can be created in the following ways:",
            "title": "Object Initialisation"
        },
        {
            "location": "/#default",
            "text": "Quaternion()   Creates a unit quaternion  1 + 0i + 0j + 0k : the quaternion representation of the real number 1.0, \nand the representation of a null rotation.  q1 = Quaternion()  For the purposes of rotation, this is a null quaternion (has no effect on the rotated vector).\nFor the purposes of quaternion multiplication, this is a unit quaternion (has no effect when multiplying)",
            "title": "Default"
        },
        {
            "location": "/#copy",
            "text": "Quaternion(other)   Clone another quaternion object  Params:   other  must be another Quaternion instance.   q2 = Quaternion(q1)  Raises:   TypeError  if the provided object is not an instance of Quaternion, or any valid positional argument as outlined below.",
            "title": "Copy"
        },
        {
            "location": "/#random",
            "text": "Quaternion.random()   Create a random quaternion that describes a rotation randomly chosen from a uniform distribution across the rotation space.  Source .  This is a class method and is called as a method of the class itself rather than on a particular instance.  q3 = Quaternion.random() # called as a class method",
            "title": "Random"
        },
        {
            "location": "/#from-scalar",
            "text": "Quaternion(scalar)   Create the quaternion representation of a scalar (single real number) value.  Params:   scalar  can be a real number, or a string representing a real number.   The imaginary part of the resulting quaternion will always be  0i + 0j + 0k .  q4 = Quaternion(4.7349)\nq4 = Quaternion(-3)\nq4 = Quaternion(\"4.7349\")\nq4 = Quaternion(\"98\")  Raises:   TypeError  if the provided value cannot be converted to a real number.  ValueError  if a provided string cannot be interpreted as a real number.",
            "title": "From scalar"
        },
        {
            "location": "/#from-elements",
            "text": "Quaternion(w, x, y, z)   Create a quaternion by specifying 4 real-numbered scalar elements.  Params:   w, x, y, z  can be real numbers, strings representing real numbers, or a mixture of both.   q5 = Quaternion(1, 1, 0, 0)\nq5 = Quaternion(\"1.0\", \"0\", \"\"0.347\"\", \"0.0\")\nq5 = Quaternion(\"1.76\", 0, 0, 0)  Raises:   TypeError  if any of the provided values cannot be converted to a real number.  ValueError  if any of the provided strings cannot be interpreted as a real number.",
            "title": "From elements"
        },
        {
            "location": "/#from-a-numpy-array",
            "text": "Quaternion(array)   Create a quaternion from the elements of a 4-element Numpy array  Params:   array  must be a 4-element numpy array containing real valued elements.   The elements  [a, b, c, d]  of the array correspond the the real, and each imaginary component respectively in the order  a + bi + cj + dk .  q6 = Quaternion(numpy.array([a, b, c, d]))  Raises:   TypeError  if any of the array contents cannot be converted to a real number.  ValueError  if the array contains less/more than 4 elements",
            "title": "From a numpy array"
        },
        {
            "location": "/#from-a-sequence",
            "text": "Quaternion(seq)   Create a quaternion object from an ordered sequence containing 4 real valued scalar elements  Params:   seq  can be a list, a tuple, a generator or any iterable sequence containing 4 values, each convertible to a real number.   The sequential elements  a, b, c, d  of the sequence correspond the the real, and each imaginary component respectively in the order  a + bi + cj + dk .  q7 = Quaternion((a, b, c, d)) // from 4-tuple\nq7 = Quaternion([a, b, c, d]) // from list of 4  Raises:   TypeError   if any of the sequence contents cannot be converted to a real number.  ValueError  if the sequence contains less/more than 4 elements",
            "title": "From a sequence"
        },
        {
            "location": "/#explicitly-by-element",
            "text": "Quaternion(a=w, b=x, c=y, d=z)   Specify each element, using any sequence of ordered labels  Params:   a=w, b=x, c=y, d=z  can be real numbers, strings representing real numbers, or a mixture of both.   q8a = Quaternion(a=1.0, b=0.0, c=0.0, d=0.0)\nq8a = Quaternion(w=1.0, x=0.0, y=0.0, z=0.0)\nq8a = Quaternion(a=1.0, i=0.0, j=0.0, k=0.0)\nq8a = Quaternion(q1=1.0, q2=0.0, q3=0.0, q4=0.0)  Rasises:  Exception behaviour is the same as initialisation by element as described above.",
            "title": "Explicitly by element"
        },
        {
            "location": "/#explicitly-by-component",
            "text": "Quaternion(scalar=s, vector=v)  or  Quaternion(real=r, imaginary=i)   Specify the scalar (real) and vector (imaginary) parts of the desired quaternion.  Params:   scalar=s  or  real=r  can be a real number, or a string representing a real number.  vector=v  or  imaginary=i  can be a sequence or numpy array containing 3 real numbers.   Either component (but not both) may be absent,  None  or empty, and will be assumed to be zero in that case.  q8b = Quaternion(scalar=1.0, vector=(0.0, 0.0, 0.0)) // Using 3-tuple\nq8b = Quaternion(scalar=None, vector=[1.0, 0.0, 0.0]) // Using list\nq8b = Quaternion(vector=numpy.array([1.0, 0.0, 0.0])) // Using Numpy 3-array\n\nq8b = Quaternion(real=1.0, imaginary=(0.0, 0.0, 0.0)) // Using 3-tuple\nq8b = Quaternion(real=None, imaginary=[1.0, 0.0, 0.0]) // Using list\nq8b = Quaternion(imaginary=numpy.array([1.0, 0.0, 0.0])) // Using Numpy 3-array  Raises:   ValueError  if the  vector  or  imaginary  component contains less/more than 3 elements",
            "title": "Explicitly by component"
        },
        {
            "location": "/#explicitly-by-rotation-parameters",
            "text": "Quaternion(axis=ax, radians=rad)  or  Quaternion(axis=ax, degrees=deg)  or  Quaternion(axis=ax, angle=theta)   Specify the angle (qualified as radians or degrees) for a rotation about an axis vector [x, y, z] to be described by the quaternion object.  Params    axis=ax  can be a sequence or numpy array containing 3 real numbers. It can have any magnitude except  0 .   radians=rad  [optional] a real number, or a string representing a real number in radians.   degrees=deg  [optional] a real number, or a string representing a real number in degrees.   angle=theta  [optional] a real number, or a string representing a real number in radians.  The  angle  (radians/degrees/angle) keyword may be absent,  None  or empty, and will be assumed to be zero in that case,\nbut the  axis  keyword must be provided to describe a meaningful rotation.  q8c = Quaternion(axis=(1.0, 0.0, 0.0), radians=math.pi/2) // Using radians asnd a 3-tuple\nq8c = Quaternion(axis=[1.0, 0.0, 0.0], degrees=90) // Using degrees and a list\nq8c = Quaternion(axis=numpy.array([1.0, 0.0, 0.0]), angle=math.pi/2) // Using radians and a Numpy 3-array  Raises:   ValueError  if  axis  is missing  ValueError  if  axis  contains less/more than 3 elements  TypeError  if  radians/degrees/angle  cannot be interpreted as a real number  ZeroDivisionError  if  axis  has 0 length.",
            "title": "Explicitly by rotation parameters"
        },
        {
            "location": "/#explicitly-by-rotation-or-transformation-matrix",
            "text": "Quaternion(matrix=R)  or  Quaternion(matrix=T)   Specify the 3x3 rotation matrix ( R ) or 4x4 transformation matrix ( T ) from which the quaternion's rotation should be created.  Params:   matrix=R  can be a 3x3 numpy array or matrix  matrix=T  can be a 4x4 numpy array or matrix. In this case, the translation part will be ignored, and only the rotational component of the matrix will be encoded within the quaternion.   Important:  The rotation component of the provided matrix must be a pure rotation i.e.  special orthogonal .  rotation = numpy.eye(3)\ntransformation = numpy.eye(4)\nq8d = Quaternion(matrix=rotation) // Using 3x3 rotation matrix\nq8d = Quaternion(matrix=transformation) // Using 4x4 transformation matrix  This code uses a modification of the algorithm described in  Converting a Rotation Matrix to a Quaternion , which is itself based on the method described  here .  Note:  Both matrices and quaternions avoid the singularities and discontinuities involved with rotation in 3 dimensions by adding extra dimensions. This has the effect that different values could represent the same rotation, for example quaternion q and -q represent the same rotation. It is therefore possible that, when converting a rotation sequence, the output may jump between these equivalent forms. This could cause problems where subsequent operations such as differentiation are done on this data. Programmers should be aware of this issue.  Raises:   ValueError  if the matrix is not 3x3 or 4x4 or if the matrix is not special orthogonal.  TypeError  if the matrix is of the wrong type",
            "title": "Explicitly by rotation or transformation matrix"
        },
        {
            "location": "/#explicitly-by-a-numpy-array",
            "text": "Quaternion(array=a)   Specify a numpy 4-array of quaternion elements to be assigned directly to the internal vector representation of the quaternion object.  This is more direct, and may be faster than feeding a numpy array as a positional argument to the initialiser.  Params:   array=a  must be a 4-element numpy array containing real valued elements.   The elements  [a, b, c, d]  of the array correspond the the real, and each imaginary component respectively in the order  a + bi + cj + dk .  q8e = Quaternion(array=numpy.array([1.0, 0.0, 0.0, 0.0]))  Raises:   ValueError  if the array vector contains less/more than 4 elements",
            "title": "Explicitly by a numpy array"
        },
        {
            "location": "/#quaternion-features",
            "text": "This section defines features available for pyquaternion's Quaternion objects  The code examples below assume the existence of a Quaternion object. You can recreate this by running the following in your Python interpreter of choice:  my_quaternion = Quaternion.random()",
            "title": "Quaternion Features"
        },
        {
            "location": "/#norm",
            "text": "norm  or  magnitude   L2 norm of the quaternion 4-vector  This should be 1.0 for a unit quaternion (versor)  Returns:  a scalar real number representing the square root of the sum of the squares of the elements of the quaternion.  my_quaternion.norm\nmy_quaternion.magnitude   is_unit(tolerance=1e-14)   Params:   tolerance  - [optional] - maximum absolute value by which the norm can differ from 1.0 for the object to be considered a unit quaternion. Defaults to  1e-14 .   Returns:   True  if the Quaternion object is of unit length to within the specified tolerance value.  False  otherwise.",
            "title": "Norm"
        },
        {
            "location": "/#inversion",
            "text": "inverse   Inverse of the quaternion object  For a unit quaternion, this is the inverse rotation, i.e. when combined with the original rotation, will result in the null rotation.  Returns:  a new Quaternion object representing the inverse of this object  inv_quaternion = my_quaternion.inverse",
            "title": "Inversion"
        },
        {
            "location": "/#conjugation",
            "text": "conjugate   Quaternion conjugate  For a unit quaternion, this is the same as the inverse.  Returns:  a new Quaternion object clone with its vector part negated  conj_quaternion = my_quaternion.conjugate",
            "title": "Conjugation"
        },
        {
            "location": "/#normalisation",
            "text": "normalised  or  unit   Get a unit quaternion (versor) copy of this Quaternion object.  A unit quaternion has a  norm  of 1.0  Note:  A Quaternion representing zero i.e.  Quaternion(0, 0, 0, 0)  cannot be normalised. In this case, the returned object will remain zero.  Returns:  a new Quaternion object clone that is guaranteed to be a unit quaternion  unless  the original object was zero, in which case the norm will remain zero.  unit_quaternion = my_quaternion.normalised\nunit_quaternion = my_quaternion.unit",
            "title": "Normalisation"
        },
        {
            "location": "/#rotation",
            "text": "rotate(vector)   Rotate a 3D vector by the rotation stored in the Quaternion object  Params:   vector  - a 3-vector specified as any ordered sequence of 3 real numbers corresponding to x, y, and z values. Some types that are recognised are: numpy arrays, lists and tuples. A 3-vector can also be represented by a Quaternion object who's scalar part is 0 and vector part is the required 3-vector. Thus it is possible to call  Quaternion.rotate(q)  with another quaternion object as an input.   Returns:  the rotated vector returned as the same type it was specified at input.  rotated_tuple       = my_quaternion.rotate((1, 0, 0)) # Returns a tuple\nrotated_list        = my_quaternion.rotate([1.0, 0.0, 0.0]) # Returns a list\nrotated_array       = my_quaternion.rotate(numpy.array([1.0, 0.0, 0.0])) # Returns a Numpy 3-array\nrotated_quaternion  = my_quaternion.rotate(Quaternion(vector=[1, 0, 0])) # Returns a Quaternion object  Raises:   TypeError  if any of the vector elements cannot be converted to a real number.  ValueError  if  vector  cannot be interpreted as a 3-vector or a Quaternion object.",
            "title": "Rotation"
        },
        {
            "location": "/#exp-and-log-maps",
            "text": "Quaternion.exp(q)  -  class method   Quaternion Exponential.  Params:   q  - the input quaternion/argument as a Quaternion object.   Returns:  A quaternion amount representing the exp(q). See  Source .  Note:  The method can compute the exponential of any quaternion.   Quaternion.log(q)  -  class method   Quaternion Logarithm.  Params:   q  - the input quaternion/argument as a Quaternion object.   Returns:  A quaternion amount representing  log(q) := (log(|q|), v/|v|acos(w/|q|)) .  Note:  The method computes the logarithm of general quaternions. See  Source  for more details.   Quaternion.exp_map(q, eta)  -  class method   Quaternion exponential map.  Find the exponential map on the Riemannian manifold described by the quaternion space.  Params:   q  - the base point of the exponential map, i.e. a Quaternion object  eta  -  the argument of the exponential map, a tangent vector, i.e. a Quaternion object   Returns:  A quaternion p such that p is the endpoint of the geodesic starting at q in the direction of eta, having the length equal to the magnitude of eta.  Note:  The exponential map plays an important role in integrating orientation variations (e.g. angular velocities). This is done by projecting quaternion tangent vectors onto the quaternion manifold.   Quaternion.sym_exp_map(q, eta)  -  class method   Quaternion symmetrized exponential map.  Find the symmetrized exponential map on the quaternion Riemannian manifold.  Params:   q  - the base point as a Quaternion object  eta  - the tangent vector argument of the exponential map as a Quaternion object   Returns:  A quaternion p.  Note:  The symmetrized exponential formulation is akin to the exponential formulation for symmetric positive definite tensors  Source   Quaternion.log_map(q, p)  -  class method   Quaternion logarithm map.  Find the logarithm map on the quaternion Riemannian manifold.  Params:   q  - the base point at which the logarithm is computed, i.e. a Quaternion object  p  - the argument of the quaternion map, a Quaternion object   Returns:  A tangent vector having the length and direction given by the geodesic joining q and p.   Quaternion.sym_log_map(q, p)  -  class method   Quaternion symmetrized logarithm map.  Find the symmetrized logarithm map on the quaternion Riemannian manifold.  Params:   q  - the base point at which the logarithm is computed, i.e. a Quaternion object  p  - the argument of the quaternion map, a Quaternion object   Returns:  A tangent vector corresponding to the symmetrized geodesic curve formulation.  Note:  Information on the symmetrized formulations given in  Source .",
            "title": "Exp and Log Maps"
        },
        {
            "location": "/#distance-computation",
            "text": "Quaternion.absolute_distance(q0, q1)  -  class method   Quaternion absolute distance.  Find the distance between two quaternions accounting for the sign ambiguity.  Params:   q0  - the first quaternion  q1  - the second quaternion   Returns:   A positive scalar corresponding to the chord of the shortest path/arc that connects q0 to q1.  Note:  This function does not measure the distance on the hypersphere, but it takes into account the fact that q and -q encode the same rotation. It is thus a good indicator for rotation similarities.   Quaternion.distance(q0, q1)  -  class method   Quaternion intrinsic distance.  Find the intrinsic geodesic distance between q0 and q1.  Params:   q0  - the first quaternion  q1  - the second quaternion   Returns:  A positive amount corresponding to the length of the geodesic arc connecting q0 to q1.  Note:  Although  q0^(-1)*q1 != q1^(-1)*q0 , the length of the path joining them is given by the logarithm of those product quaternions, the norm of which is the same.   Quaternion.sym_distance(q0, q1)  -  class method   Quaternion symmetrized distance.  Find the intrinsic symmetrized geodesic distance between q0 and q1.  Params:   q0  - the first quaternion  q1  - the second quaternion   Returns:  A positive amount corresponding to the length of the symmetrized geodesic curve connecting q0 to q1.  Note:  This formulation is more numerically stable when performing iterative gradient descent on the Riemannian quaternion manifold.\nHowever, the distance between q and -q is equal to pi, rendering this formulation not useful for measuring rotation similarities when the samples are spread over a \"solid\" angle of more than pi/2 radians (the spread refers to quaternions as point samples on the unit hypersphere).",
            "title": "Distance computation"
        },
        {
            "location": "/#interpolation",
            "text": "Quaternion.slerp(q0, q1, amount=0.5)  -  class method   Find a valid quaternion rotation at a specified distance along the minor arc of a great circle passing through any two existing quaternion endpoints lying on the unit radius hypersphere.  Source  This is a class method and is called as a method of the class itself rather than on a particular instance.  Params:   q0  - first endpoint rotation as a Quaternion object  q1  - second endpoint rotation as a Quaternion object  amount  - interpolation parameter between 0 and 1. This describes the linear placement position of the result along the arc between endpoints; 0 being at  q0  and 1 being at  q1 . Defaults to the midpoint (0.5).   Returns: \na new Quaternion object representing the interpolated rotation. This is guaranteed to be a unit quaternion.  Note:  This feature only makes sense when interpolating between unit quaternions (those lying on the unit radius hypersphere). Calling this method will implicitly normalise the endpoints to unit quaternions if they are not already unit length.  q0 = Quaternion(axis=[1, 1, 1], angle=0.0)\nq1 = Quaternion(axis=[1, 1, 1], angle=3.141592)\nq  = Quaternion.slerp(q0, q1, 2.0/3.0) # Rotate 120 degrees (2 * pi / 3)   Quaternion.intermediates(q_start, q_end, n, include_endpoints=False)  -  class method   Generator method to get an iterable sequence of  n  evenly spaced quaternion rotations between any two existing quaternion endpoints lying on the unit radius hypersphere. This is a convenience function that is based on  Quaternion.slerp()  as defined above.  This is a class method and is called as a method of the class itself rather than on a particular instance.  Params:   q_start  - initial endpoint rotation as a Quaternion object  q_end  - final endpoint rotation as a Quaternion object  n  - number of intermediate quaternion objects to include within the interval  include_endpoints  - [optional] - If set to  True , the sequence of intermediates will be 'bookended' by  q_start  and  q_end , resulting in a sequence length of  n + 2 . If set to  False , endpoints are not included. Defaults to  False .   Yields: \na generator object iterating over a sequence of intermediate quaternion objects.  Note:  This feature only makes sense when interpolating between unit quaternions (those lying on the unit radius hypersphere). Calling this method will implicitly normalise the endpoints to unit quaternions if they are not already unit length.  q0 = Quaternion(axis=[1, 1, 1], angle=0.0)\nq1 = Quaternion(axis=[1, 1, 1], angle=2 * 3.141592 / 3)\nfor q in Quaternion.intermediates(q0, q1, 8, include_endpoints=True):\n    v = q.rotate([1, 0, 0])\n    print(v)",
            "title": "Interpolation"
        },
        {
            "location": "/#differentiation",
            "text": "derivative(rate)   Get the instantaneous quaternion derivative representing a quaternion rotating at a 3D rate vector  rate  Params:   rate  - numpy 3-array (or array-like) describing rotation rates about the global x, y and z axes respectively.   Returns:  A unit quaternion describing the rotation rate  q_dot = my_quaternion.derivative([0, 0, 3.14159]) # Rotate about z at 0.5 rotation per second  Raises:   TypeError   if any of  rate  contents cannot be converted to a real number.  ValueError  if  rate  contains less/more than 3 elements",
            "title": "Differentiation"
        },
        {
            "location": "/#integration",
            "text": "integrate(rate, timestep)   Advance a time varying quaternion to its value at a time  timestep  in the future.  The Quaternion object will be modified to its future value. It is guaranteed to remain a unit quaternion.  Params:   rate  - numpy 3-array (or array-like) describing rotation rates about the global x, y and z axes respectively.  timestep  - interval over which to integrate into the future. Assuming  now  is  T=0 , the integration occurs over the interval  T=0  to  T=timestep . Smaller intervals are more accurate when  rate  changes over time.   Note 1:  This feature only makes sense when referring to a unit quaternion. Calling this method will implicitly normalise the Quaternion object to a unit quaternion if it is not already one. Many quaternion integration algorithms will have unwanted scaling effects leading a quaternion object to become non-unit over time, thus the object is re-normalised with each call to  integrate() . Because this method is often called very frequently (every  timestep  for realtime simulation) an optimised re-normalisation is performed. See  _fast_normalise()  for more info.  Note 2:  The solution is in closed form given the assumption that  rate  is constant over the interval of length  timestep . This algorithm is not an exact solution to the differential equation over any interval where the angular rates are not constant. It is a second order approximation, meaning the integral error contains terms proportional to  timestep ** 3  and higher powers.  >>> q = Quaternion() # null rotation\n>>> q.integrate([2*pi, 0, 0], 0.25) # Rotate about x at 1 rotation per second\n>>> q == Quaternion(axis=[1, 0, 0], angle=(pi/2))\nTrue\n>>>  Raises:   TypeError   if any of  rate  contents cannot be converted to a real number.  ValueError  if  rate  contains less/more than 3 elements",
            "title": "Integration"
        },
        {
            "location": "/#accessing-matrix-form",
            "text": "rotation_matrix  &  transformation_matrix   Get the 3x3 rotation or 4x4 homogeneous transformation matrix equivalent of the quaternion rotation.  Returns:   Quaternion.rotation_matrix  : a 3x3 orthogonal rotation matrix as a 3x3 Numpy array  Quaternion.transformation_matrix  : a 4x4 homogeneous transformation matrix as a 4x4 Numpy array   Note 1:  This feature only makes sense when referring to a unit quaternion. Calling this method will implicitly normalise the Quaternion object to a unit quaternion if it is not already one.  Note 2:  Both matrices and quaternions avoid the singularities and discontinuities involved with rotation in 3 dimensions by adding extra dimensions. This has the effect that different values could represent the same rotation, for example quaternion q and -q represent the same rotation. It is therefore possible that, when converting a rotation sequence, the output may jump between different but equivalent forms. This could cause problems where subsequent operations such as differentiation are done on this data. Programmers should be aware of this issue.  R = my_quaternion.rotation_matrix         # 3x3 rotation matrix\nT = my_quaternion.transformation_matrix   # 4x4 transformation matrix",
            "title": "Accessing matrix form"
        },
        {
            "location": "/#accessing-rotation-axis",
            "text": "axis  or  get_axis(undefined=[0,0,0])   Get the axis or vector about which the quaternion rotation occurs  For a null rotation (a purely real quaternion), the rotation angle will always be  0 , but the rotation axis is undefined. It is by default assumed to be  [0, 0, 0] .  Note:  In the case of a null rotation, retrieving the axis is geometrically meaningless, as it could be any of an infinite set of vectors.\nBy default, ( [0, 0, 0] ) is returned in this instance, but should this causes undesired behaviour, please use the\nalternative  get_axis()  form, specifying the  undefined  keyword to return a vector of your choice.  Params:   undefined  - [optional] - specify the axis vector that should define a null rotation.    Returns:  a Numpy unit 3-vector describing the Quaternion object's axis of rotation.  Note 1:  This feature only makes sense when referring to a unit quaternion. Calling this method will implicitly normalise the Quaternion object to a unit quaternion if it is not already one.  Note 2:  Both matrices and quaternions avoid the singularities and discontinuities involved with rotation in 3 dimensions by adding extra dimensions. This has the effect that different values could represent the same rotation, for example quaternion q and -q represent the same rotation. It is therefore possible that, when converting a rotation sequence to axis/angle representation, the output may jump between different but equivalent forms. This could cause problems where subsequent operations such as differentiation are done on this data. Programmers should be aware of this issue.  u = my_quaternion.axis # Unit vector about which rotation occurs  #or \nu = my_quaternion.get_axis(undefined=[1, 0, 0]) # Prefers a custom axis vector in the case of undefined result",
            "title": "Accessing rotation axis"
        },
        {
            "location": "/#accessing-rotation-angle",
            "text": "angle ,  degrees  or  radians   Get the angle (in radians) describing the magnitude of the quaternion rotation about its rotation axis. This is guaranteed to be within the range (-pi:pi) with the direction of rotation indicated by the sign.  When a particular rotation describes a 180 degree rotation about an arbitrary axis vector  v , the conversion to axis / angle representation may jump discontinuously between all permutations of  (-pi, pi)  and  (-v, v) , each being geometrically equivalent (see Note 2 below).  Returns:  a real number in the range (-pi:pi) describing the angle of rotation in radians about a Quaternion object's axis of rotation.  Note 1:  This feature only makes sense when referring to a unit quaternion. Calling this method will implicitly normalise the Quaternion object to a unit quaternion if it is not already one.  Note 2:  Both matrices and quaternions avoid the singularities and discontinuities involved with rotation in 3 dimensions by adding extra dimensions. This has the effect that different values could represent the same rotation, for example quaternion q and -q represent the same rotation. It is therefore possible that, when converting a rotation sequence to axis/angle representation, the output may jump between different but equivalent forms. This could cause problems where subsequent operations such as differentiation are done on this data. Programmers should be aware of this issue.  theta = my_quaternion.angle # Magnitude of rotation about the prescribed axis, in radians\ntheta = my_quaternion.radians # Equivalent, but explicit\ntheta = my_quaternion.degrees # The same, but in degrees",
            "title": "Accessing rotation angle"
        },
        {
            "location": "/#accessing-real-components",
            "text": "scalar  or  real   Get the real or scalar component of the Quaternion object  A quaternion can be described in terms of a scalar and vector part, q = [r,  v ] where:   r is the scalar coefficient of the real part of the quaternion i.e.  a  in a + b i  + c j  + d k  v  is the 3-vector of coefficients to the imaginary parts of the quaternion i.e. [b, c, d] in a + b i  + c j  + d k   This property returns r  Returns  the scalar, real valued element of the Quaternion object  r = my_quaternion.scalar\nr = my_quaternion.real",
            "title": "Accessing real components"
        },
        {
            "location": "/#accessing-imaginary-components",
            "text": "vector  or  imaginary   Get the imaginary or vector component of the Quaternion object. This can be used, for example, to extract the stored vector when a pure-imaginary quaternion object is used to describe a vector within the three-dimensional vector space.  A quaternion can be described in terms of a scalar and vector part, q = [r,  v ] where:   r is the scalar coefficient of the real part of the quaternion i.e.  a  in a + b i  + c j  + d k  v  is the 3-vector of coefficients to the imaginary parts of the quaternion i.e. [b, c, d] in a + b i  + c j  + d k   This property returns  v  Returns  Numpy 3-array of the 3 imaginary elements of the Quaternion object  v = my_quaternion.vector\nv = my_quaternion.imaginary",
            "title": "Accessing imaginary components"
        },
        {
            "location": "/#accessing-individual-elements",
            "text": "elements   Return all four elements of the quaternion object. Result is not guaranteed to be a unit 4-vector.  Returns:  a numpy 4-array of real numbered coefficients.  >>> a = my_quaternion.elements\n>>> print(\"{} + {}i + {}j + {}k\".format(a[0], a[1], a[2], a[3]))\n    -0.6753741977725701 + 0.4624451782281068i + -0.059197245808339134j + 0.5714103921047806k   __getitem__(index)   my_quaternion[i]  returns the real numbered element at the specified index  i  in the quaternion 4-array  Params:   index  - integer in the range [-4:3] inclusive   >>> print(\"{} + {}i + {}j + {}k\".format(my_quaternion[0], my_quaternion[1], my_quaternion[2], my_quaternion[3]))\n   -0.6753741977725701 + 0.4624451782281068i + -0.059197245808339134j + 0.5714103921047806k\n>>> print(\"{} + {}i + {}j + {}k\".format(my_quaternion[-4], my_quaternion[-3], my_quaternion[-2], my_quaternion[-1]))\n   -0.6753741977725701 + 0.4624451782281068i + -0.059197245808339134j + 0.5714103921047806k\n>>>  Raises:   IndexError  if the index provided is invalid  TypeError  or  ValueError  if the index cannot be interpreted as an integer",
            "title": "Accessing individual elements"
        },
        {
            "location": "/#modifying-individual-elements",
            "text": "__setitem__(index, value)   my_quaternion[i] = x  sets the element at the specified index  i  in the quaternion 4-array to the specified value  x .  Params:   index  - integer in the range [-4:3] inclusive  value  - real value to be inserted into the quaternion array at  index   >>> str(my_quaternion)\n    '-0.653 -0.127i -0.220j +0.714k'\n>>> my_quaternion[2] = 9\n>>> str(my_quaternion)\n    '-0.653 -0.127i +9.000j +0.714k'\n>>>  Raises:   IndexError  if the index provided is invalid  TypeError  or  ValueError  if the value cannot be interpreted as a real number",
            "title": "Modifying individual elements"
        },
        {
            "location": "/#quaternion-operations",
            "text": "This section defines operations applicable to pyquaternion's Quaternion objects.  The code examples below assume the existence of a Quaternion object. You can recreate this by running the following in your Python interpreter of choice:  my_quaternion = Quaternion.random()",
            "title": "Quaternion Operations"
        },
        {
            "location": "/#string-representation",
            "text": "__str__()   str(my_quaternion)  returns an informal, nicely printable string representation of the Quaternion object.  Source  >>> str(my_quaternion)\n    '-0.810 +0.022i -0.563j -0.166k'\n>>> print(my_quaternion)\n    -0.810 +0.022i -0.563j -0.166k\n>>>   __repr__()   repr(my_quaternion)  returns the 'official' string representation of the Quaternion object.  This is a string representation of a valid Python expression that could be used to recreate an object with the same value (given an appropriate environment).  Source  >>> repr(my_quaternion)\n    'Quaternion(-0.80951530224438595, 0.022231097065902788, -0.56268832802625091,-0.16604999023923223)'\n>>> my_quaternion\n    Quaternion(-0.80951530224438595, 0.022231097065902788, -0.56268832802625091,-0.16604999023923223)\n>>>   __format__(format_spec)   a_string_containing_{format_spec}_placeholders.format(my_quaternion)  inserts a customisable, nicely printable string representation of the Quaternion object into the respective places in the provided string.  Source  The syntax for  format_spec  mirrors that of the built in format specifiers for floating point types. Check out the official Python  format specification mini-language  for details.\nAn empty  format_spec  string will result in the same behaviour as the  Quaternion.__str__() .  >>> \"My quaternion is: {}\".format(my_quaternion)\n    'My quaternion is: -0.810 +0.022i -0.563j -0.166k'\n>>> \"My quaternion is: {:+.6}\".format(my_quaternion)\n    'My quaternion is: -0.809515 +0.0222311i -0.562688j -0.16605k'",
            "title": "String Representation"
        },
        {
            "location": "/#bool",
            "text": "__bool__()  or  __nonzero__()   Returns:   False  within a logical context if the Quaternion object is zero, i.e.  Quaternion(0.0, 0.0, 0.0, 0.0)  or  True  otherwise.  The bitwise not operator  ~  can be used to invert the boolean value, however the keyword  not  (logical) is preferred.  Note:  This does not evaluate the booleanity of a quaternion rotation. A non-zero Quaternion object such as  Quaternion(1.0, 0.0, 0.0, 0.0)  will have a boolean value of  True  even though it represents a  null  rotation.  >>> Quaternion() == True\nTrue\n>>> not Quaternion() == False\nTrue\n>>> Quaternion(scalar=0.0) == False\nTrue",
            "title": "Bool"
        },
        {
            "location": "/#equality",
            "text": "__eq__(other)   q1 == q2  returns  True  if all corresponding elements are equal between two Quaternion objects  q1  and  q2 , or  False  otherwise.  The inequality operator  !=  can also be used to verify inequality in a similar way.  Because comparisons are carried out on floating point elements, equality is considered  True  when the absolute difference between elements falls below a threshold error. This is determined by  numpy.allclose()  with an absolute tolerance of  1.0e-14  and a relative tolerance of  1.0e-13 . As a result, objects differing by very small individual element differences may be considered equal.  Note:  This does not directly evaluate the equality of a quaternion rotation. For example, unit Quaternions q and -q will have an equality of  False  even though they represent the equivalent rotation.  >>> Quaternion(1, 0, 1, 1) == Quaternion(scalar=1.0, vector=[0.0, 1.0, 1.0])\nTrue\n>>> Quaternion(1, 0, 1, 1) == Quaternion(scalar=1.0, vector=[0.1, 1.0, 1.0])\nFalse\n>>> Quaternion() != Quaternion(scalar=2)\nTrue",
            "title": "Equality"
        },
        {
            "location": "/#negation",
            "text": "__neg__()   -q  is the quaternion formed by the element wise negation of the elements of  q .  Returns:  a new Quaternion object representing the negation of the single operand.\nIf the operand is a unit quaternion, the result is guaranteed to be a unit quaternion.  >>> my_elements = my_quaternion.elements() # Numpy array of individual elements\n>>> -my_quaternion == Quaternion(-my_elements)\nTrue",
            "title": "Negation"
        },
        {
            "location": "/#addition",
            "text": "__add__(other)   q1 + q2  is the quaternion formed by element-wise sum of  q1  and  q2 .  Source  Note:  If 'other' is not a Quaternion object, it will be converted to one, using the behaviour described in the [object initialisation][initialisation] section. As described therein, a  TypeError  or  ValueError  will be raised if this conversion fails.  Returns:  a new Quaternion object representing the sum of the inputs.\nThe sum is  not  guaranteed to be a unit quaternion.  >>> q1 = Quaternion.random()\n>>> q2 = Quaternion.random()\n>>> q1 + q2 == Quaternion(q1.elements() + q2.elements())\nTrue",
            "title": "Addition"
        },
        {
            "location": "/#subtraction",
            "text": "__sub__(other)   q1 - q2  is the quaternion formed by element-wise difference between  q1  and  q2 .  Source  Note:  If 'other' is not a Quaternion object, it will be converted to one, using the behaviour described in the [object initialisation][initialisation] section. As described therein, a  TypeError  or  ValueError  will be raised if this conversion fails.  Returns:  a new Quaternion object representing the difference of the inputs.\nThe difference is  not  guaranteed to be a unit quaternion.  >>> q1 = Quaternion.random()\n>>> q2 = Quaternion.random()\n>>> q1 - q2 == Quaternion(q1.elements() - q2.elements())\nTrue",
            "title": "Subtraction"
        },
        {
            "location": "/#multiplication",
            "text": "__mul__(other)   q1 * q2  is the quaternion formed by Hamilton product of  q1  and  q2 .  Source  The Hamiltonian product is not commutative. Ensure your operands are correctly placed.  Note:  If 'other' is not a Quaternion object, it will be converted to one, using the behaviour described in the [object initialisation][initialisation] section. As described therein, a  TypeError  or  ValueError  will be raised if this conversion fails. As a result this operation holds true for scalar multiplication as scalars are converted to pure real Quaternion objects.  Returns:  a new Quaternion object representing the Hamilton product of the inputs.\nIf the two multiplicands are unit quaternions, the product is guaranteed to be a unit quaternion.  >>> one = Quaternion(1, 0, 0, 0)\n>>> i   = Quaternion(0, 1, 0, 0)\n>>> j   = Quaternion(0, 0, 1, 0)\n>>> k   = Quaternion(0, 0, 0, 1)\n>>> (i * i) == (j * j) == (k * k) == (i * j * k) == -1\nTrue",
            "title": "Multiplication"
        },
        {
            "location": "/#division",
            "text": "__truediv__(other)  or  __div__(other)   q1 / q2  is the quaternion formed by Hamilton product of  q1  and  q2.inverse() .  Source  The Hamiltonian product is not commutative. Ensure your operands are correctly placed.  Note:  If 'other' is not a Quaternion object, it will be converted to one, using the behaviour described in the [object initialisation][initialisation] section. As described therein, a  TypeError  or  ValueError  will be raised if this conversion fails. As a result this operation holds true for scalar division as scalars are converted to pure real Quaternion objects.  Returns:  a new Quaternion object representing the Hamilton quotient of the inputs.\nIf the dividend and divisor are unit quaternions, the quotient is guaranteed to be a unit quaternion.  >>> my_quaternion / my_quaternion == Quaternion(1.0)\nTrue",
            "title": "Division"
        },
        {
            "location": "/#exponentiation",
            "text": "__pow__(other)   q ** p  is the quaternion formed by raising the Quaternion  q1  to the power of  p  for any real  p .  Source  Returns:  a new Quaternion object representing the the object raised to the power of the input.\nIf the base object is a unit quaternion, the result is guaranteed to be a unit quaternion.  >>> one = Quaternion(1, 0, 0, 0)\n>>> i   = Quaternion(0, 1, 0, 0)\n>>> j   = Quaternion(0, 0, 1, 0)\n>>> k   = Quaternion(0, 0, 0, 1)\n>>> (i ** 2) == (j ** 2) == (k ** 2) == -1\nTrue  Raises:   TypeError  if  other  cannot be interpreted as a real number.",
            "title": "Exponentiation"
        }
    ]
}